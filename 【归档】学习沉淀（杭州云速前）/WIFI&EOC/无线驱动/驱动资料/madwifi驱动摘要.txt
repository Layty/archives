Madwifi驱动摘要  
/*原创文章，欢迎转载，请注明出处：http://cy158358.cublog.cn/*/

 

通过Madwifi驱动我们可以基于一个物理网卡设备来创建多个虚拟的接口。每一个虚拟接口都能工作在不同的模式下，例如AP、STA、IBSS（adhoc）、Monitor（监视）和WDS（桥方式）。

下面将通过Madwifi的驱动概要的描述一下工作在AP和STA方式下的行为。

1．  AP模式

下面是AP模式下的状态图：



 

当驱动被加载的时候，它会去探测物理设备是否存在，然后通过ath_attach()函数安装此设备。同时，驱动会自动创建一个虚拟的网络接口，通过函数ieee80211_create_vap()实现。这个虚拟网络接口的初始状态为INIT，在此状态下硬件不会接收数据包。

当实际的AP接口开始工作（例如通过ifconfig ath0 up命令激活），驱动会将对硬件进行适当的设置并且进入SCAN状态。在SCAN状态下，AP会扫描所有它支持的通道。扫描包括两个方面，一个是主动扫描，即AP会发送适当的请求报文；一个是被动扫描，即AP监听临近AP的beacons。在SCAN状态下，AP不会传输数据报。

在所有的通道都扫描完成以后，AP选择一个无线信号强度最低的通道然后进入RUN状态（ap_end()）。在RUN状态下，AP执行一个存取节点的普通操作。它约每隔100ms向外广播一个beacon消息（ath_beacon_send()）,应答其它AP发送的请求，应答终端发送来的认证消息和连接/重连接消息，并且传输数据包。

当接口被关闭的时候，AP会发送取消认证消息到每一个连接了的终端，然后释放所它们所占有的资源并进入INIT状态。

需要注意控制消息的使用，如：RTS、CTS和ACK，它们是被驱动HAL（硬件抽象层）控制的，开源部分不会处理这些控制消息。

 

2．  SAT模式

SAT模式的转台迁移图如下：

 

 

具体的工作过程之后描述

 

3．  数据接收

下图是主要的接收处理流程示意图：

 

大多数的CSMA/CA机制被贯彻在HAL或者硬件中。当一个新的包到达时，开源的驱动部分是通过中断来获取通知的（ath_intr()）。包被linux的tasklet来处理（ath_rx_tasklet()），这个包所在skb结构被找到并且它的目标节点正确。函数ieee80211_input()接收各种不同类型的包，在这个函数中管理报文包被传递给ieee80211_recv_mgmt()函数处理，数据包被做相关的处理后变成以太帧格式然后传送给linux内核（netif_rx()）或者，如果工作在桥模式下，则通过dev_queue_xmit()发送此数据包

 

4． 数据的发送

下面是主要的发送处理流程：

 

Linux内核通过dev->hard_start_xmit轮流调用虚拟接口的ieee80211_hardstart()函数和物理接口的ath_hardstart（）函数实现包的传输。ath_hardstart（）函数将以太格式的包封装成802.11格式的包。ath_tx_start（）函数将需要加密的包进行加密处理，并将保存此包的skb映射到DMA缓冲，并根据包的优先级选定一个传输队列（QoS control）。ath_tx_txqaddbuf()函数将映射后的缓冲（buffer）插入到选定的传输队列里面并通知HAL开始传输。

管理帧由802.11层产生。它们通过ieee80211_mgmt_output（）函数发送。

Beacon消息由HAL触发。当发送beacon消息的时间到达，HAL会制造一个中断，然后调用函数ath_beacon_send()来发送。Beacon消息直接被传递到HAL并发送。

HAL成功发送完一个包后也会产生一个中断来通知驱动。过程如下所示：

 

函数ath_tx_tasklet()会更新发送相关的信息。如果有工作在监视模式（monitor mode）的虚拟端口存在，这个包会在函数ath_tx_capture()中被传递给监视接口。

 
 
 
 
