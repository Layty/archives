<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0079)http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-83092/index.html -->
<html class=" regenabled browserSafari radius jsenabled regloaded"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter&nbsp;4 Programming
with Synchronization Objects (Multithreaded Programming Guide) </title><link type="text/css" rel="stylesheet" href="./Chapter 4 Programming with Synchronization Objects (Multithreaded Programming Guide)_files/default.css"><link type="text/css" rel="stylesheet" href="./Chapter 4 Programming with Synchronization Objects (Multithreaded Programming Guide)_files/www.css"><link type="text/css" rel="stylesheet" href="./Chapter 4 Programming with Synchronization Objects (Multithreaded Programming Guide)_files/dsc.css"><script language="javascript1.2" type="text/javascript" src="./Chapter 4 Programming with Synchronization Objects (Multithreaded Programming Guide)_files/sniff.js"></script></head><body><div id="a0v0" class="a0 a0v0"><div class="a2w0"><div id="a2v7" class="a2"><div class="a2w1"><div class="a2w2"><div class="a2w3"><div class="a2w4"><div class="a2topiclinks"><div class="a2x1"></div><a id="sunlogo" title="Oracle Home Page" href="http://www.oracle.com/"><img width="98" height="58" border="0" alt="Oracle Homeage" src="./Chapter 4 Programming with Synchronization Objects (Multithreaded Programming Guide)_files/a.gif"></a><img width="1" height="33" border="0" alt="test" src="./Chapter 4 Programming with Synchronization Objects (Multithreaded Programming Guide)_files/a.gif" id="venuespacer"></div></div></div></div></div></div></div><div id="breadcrumb"><a href="http://www.oracle.com/technetwork/indexes/documentation/index.html">Documentation Home</a> &nbsp;&gt; <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/index.html">Multithreaded Programming Guide </a>   &nbsp;&gt; Chapter&nbsp;4 Programming
with Synchronization Objects</div><br><div class="pagetitle" id="sharepage">Multithreaded Programming Guide</div><div class="d8 d8v1" style="margin: 10px;"><div class="d8w1"><div class="d8w2"><div class="d8w3"><div class="d8w4"><ul><li class="d8left"><a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/attrib-74380/index.html"><em>Previous</em>: Chapter&nbsp;3 Thread Attributes</a></li><li class="d8right"><a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/gen-12013/index.html"><em>Next</em>: Chapter&nbsp;5 Programming With the Solaris
Software</a></li></ul></div></div></div></div></div><div class="pc11 imgMax-590" style="margin: 10px;"><a xmlns:str="http://xml.apache.org/xalan/java/java.lang.String" name="6mba5vpsn"></a><h1 class="sol">Chapter&nbsp;4 Programming
with Synchronization Objects</h1>
<a name=""></a><p>This chapter describes the synchronization types that are available
with threads. The chapter also discusses when and how to use synchronization.</p>
<a name=""></a><ul>
<li>
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-28983/index.html">Mutual Exclusion Lock Attributes</a>
</p>


</li>
<li>
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-110/index.html">Using Mutual Exclusion Locks</a>
</p>


</li>
<li>
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/ggecq/index.html">Using Spin Locks</a>
</p>


</li>
<li>
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-91921/index.html">Condition Variable Attributes</a>
</p>


</li>
<li>
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-21067/index.html">Using Condition Variables</a>
</p>


</li>
<li>
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-11157/index.html">Synchronization With Semaphores</a>
</p>


</li>
<li>
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-52/index.html">Read-Write Lock Attributes</a>
</p>


</li>
<li>
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-124/index.html">Using Read-Write Locks</a>
</p>


</li>
<li>
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/gfwek/index.html">Using Barrier Synchronization</a>
</p>


</li>
<li>
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-46/index.html">Synchronization Across Process Boundaries</a>
</p>


</li>
<li>
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-31059/index.html">Comparing Primitives</a>
</p>


</li>
</ul>
<p>Synchronization objects are variables in memory that you access just
like data. Threads in different processes can communicate with each other
through synchronization objects that are placed in threads-controlled shared
memory. The threads can communicate with each other even though the threads
in different processes are generally invisible to each other.</p>
<p>Synchronization objects can also be placed in files. The synchronization
objects can have lifetimes beyond the life of the creating process.</p>
<p>The available types of synchronization objects are</p>
<a name=""></a><ul>
<li>
<p>Mutex locks</p>


</li>
<li>
<p>Condition variables</p>


</li>
<li>
<p>Read-Write locks</p>


</li>
<li>
<p>Semaphores</p>


</li>
</ul>
<p>Situations that can benefit from the use of synchronization include
the following:</p>
<a name=""></a><ul>
<li>
<p>Synchronization is the only way to ensure consistency of shared
data.</p>


</li>
<li>
<p>Threads in two or more processes can use a single synchronization
object jointly. Because reinitializing a synchronization object sets the object
to the <b>unlocked</b> state, the synchronization object should
be initialized by only one of the cooperating processes.</p>


</li>
<li>
<p>Synchronization can ensure the safety of mutable data.</p>


</li>
<li>
<p>A process can map a file and direct a thread in this process
get a record's lock. Once the lock is acquired, any thread in any process
mapping the file attempting to acquire the lock is blocked until the lock
is released.</p>


</li>
<li>
<p>Accessing a single primitive variable, such as an integer,
can use more than one memory cycle for a single memory load. More than one
memory cycle is used where the integer is not aligned to the bus data width
or is larger than the data width. While integer misalignment cannot happen
on the SPARC architecture, portable programs cannot rely on the proper alignment.</p>


</li>
</ul>
<hr><b>Note – </b><p>
<a name="sync-ix255"></a><a name="sync-ix256"></a><a name="sync-ix257"></a><a name="sync-ix258"></a><a name="sync-ix259"></a><a name="sync-ix260"></a><a name="sync-ix261"></a><a name="sync-ix262"></a><a name="sync-ix263"></a><a name="sync-ix264"></a><a name="sync-ix265"></a><a name="sync-ix266"></a><a name="sync-ix267"></a><a name="sync-ix268"></a><a name="sync-ix269"></a><a name="sync-ix270"></a><a name="sync-ix271"></a>On 32-bit architectures, a <code>long</code> <code>long</code> is
not atomic. (An <b>atomic</b> operation cannot be divided into
smaller operations.) A <code>long</code> <code>long</code> is read and written
as two 32-bit quantities. The types <code>int</code>, <code>char</code> , <code>float</code>, and pointers are atomic on SPARC architecture machines and Intel
Architecture machines.</p>
<hr>

<a name="6mba5vpsp"></a><h1 class="sol">Mutual Exclusion Lock Attributes</h1>
<p>
<a name="indexterm-83"></a><a name="sync-ix272"></a>Use mutual exclusion locks
(mutexes) to serialize thread execution. Mutual exclusion locks synchronize
threads, usually by ensuring that only one thread at a time executes a critical
section of code. Mutex locks can also preserve single-threaded code.</p>
<p>
<a name="indexterm-84"></a>To change the default mutex attributes,
you can declare and initialize an attribute object. Often, the mutex attributes
are set in one place at the beginning of the application so the attributes
can be located quickly and modified easily. <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vpsp/index.html#sync-tbl-1">Table 4–1</a> lists the functions that manipulate mutex attributes.</p>
<a name="sync-tbl-1"></a>Table 4–1  Mutex Attributes Routines<table width="100%" cellpadding="10" cellspacing="0" border="2">
<caption>
<b></b>
</caption>
<thead>
<tr>
<th scope="col" align="left" valign="top">
<p>Operation&nbsp;</p>

</th><th scope="col" align="left" valign="top">
<p>Related Function Description&nbsp;</p>

</th>
</tr>

</thead>
<tbody>
<tr>
<td align="left" valign="top">
<p>Initialize a mutex attribute object&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-26886/index.html"><tt>pthread_mutexattr_init</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Destroy a mutex attribute object&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-87050/index.html"><tt>pthread_mutexattr_destroy</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Set the scope of a mutex&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-21323/index.html"><tt>pthread_mutexattr_setpshared</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Get the scope of a mutex&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-52492/index.html"><tt>pthread_mutexattr_getpshared</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Set the mutex type attribute&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-75/index.html"><tt>pthread_mutexattr_settype</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Get the mutex type attribute&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-77/index.html"><tt>pthread_mutexattr_gettype</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Set mutex attribute's protocol&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-89/index.html"><tt>pthread_mutexattr_setprotocol</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Get mutex attribute's protocol&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-92/index.html"><tt>pthread_mutexattr_getprotocol</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Set mutex attribute's priority ceiling&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-95/index.html"><tt>pthread_mutexattr_setprioceiling</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Get mutex attribute's priority ceiling&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-98/index.html"><tt>pthread_mutexattr_getprioceiling</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Set mutex's priority ceiling&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-85/index.html"><tt>pthread_mutex_setprioceiling</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Get mutex's priority ceiling&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-86/index.html"><tt>pthread_mutex_getprioceiling</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Set mutex's robust attribute&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-103/index.html"><tt>pthread_mutexattr_setrobust_np</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Get mutex's robust attribute&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-104/index.html"><tt>pthread_mutexattr_getrobust_np</tt> Syntax</a>
</p>

</td>
</tr>

</tbody>
</table>
<p> 
</p><a name="6mba5vpsr"></a><h2 class="sol">Initializing a Mutex Attribute Object</h2>
<p>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutexattr-init-3c/index.html">pthread_mutexattr_init(3C)</a> to initialize attributes that are associated with
the mutex object to their default values. Storage for each attribute object
is allocated by the threads system during execution.</p>
<a name="6mba5vpst"></a><h3 class="sol">
<tt>pthread_mutexattr_init</tt> Syntax</h3>
<a name="sync-ix279"></a><a name=""></a><pre>int pthread_mutexattr_init(pthread_mutexattr_t *<var>mattr</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;

pthread_mutexattr_t <var>mattr</var>;
int <var>ret</var>;

/* initialize an attribute to default value */
<var>ret</var> = pthread_mutexattr_init(&amp;<var>mattr</var>); </pre>
<p>
<a name="indexterm-85"></a><var>mattr</var> is an <code>opaque</code> type
that contains a system-allocated attribute object. See <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vpst/index.html#ggeng">Table 4–2</a> for information about the attributes in the <var>mattr</var> object. </p>
<p>Before a mutex attribute object can be reinitialized, the object must
first be destroyed by a call to <tt>pthread_mutexattr_destroy(3C)</tt>.
The  <kbd><b>pthread_mutexattr_init()</b></kbd> call results in the allocation
of an opaque object. If the object is not destroyed, a memory leak results.</p>
<a name="ggeng"></a>Table 4–2  Default Attribute Values for <var>mattr</var><table width="100%" cellpadding="10" cellspacing="0" border="2">
<caption>
<b></b>
</caption>
<thead>
<tr>
<th scope="col" align="left" valign="top">
<p>Attribute&nbsp;</p>

</th><th scope="col" align="left" valign="top">
<p>Value&nbsp;</p>

</th><th scope="col" align="left" valign="top">
<p>Result&nbsp;</p>

</th>
</tr>

</thead>
<tbody>
<tr>
<td align="left" valign="top">
<p>
<var>pshared</var>
</p>

</td><td align="left" valign="top">
<p>
<tt>PTHREAD_PROCESS_PRIVATE</tt>
</p>

</td><td align="left" valign="top">
<p>The initialized mutex can be used within a process. Only those threads
created by the same process can operate on the mutex.&nbsp;</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>
<var>type</var>
</p>

</td><td align="left" valign="top">
<p>
<tt>PTHREAD_MUTEX_DEFAULT</tt>
</p>

</td><td align="left" valign="top">
<p>The Solaris Pthreads implementation maps <tt>PTHREAD_MUTEX_DEFAULT</tt> to <tt>PTHREAD_MUTEX_NORMAL</tt>, which does not detect deadlock.</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>
<var>protocol</var>
</p>

</td><td align="left" valign="top">
<p>
<tt>PTHREAD_PRIO_NONE</tt>
</p>

</td><td align="left" valign="top">
<p>Thread priority and  scheduling are not affected by the priority of
the mutex owned by the thread.&nbsp;</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>
<var>prioceiling</var>
</p>

</td><td align="left" valign="top">
<p>–&nbsp;</p>

</td><td align="left" valign="top">
<p>The <var>prioceiling</var> value is drawn from the existing
priority range for the <tt>SCHED_FIFO</tt> policy, as returned by
the <kbd><b>sched_get_priority_min()</b></kbd> and <kbd><b>sched_get_priority_max()</b></kbd> functions. This priority range is determined by the Solaris version
on which the mutex is created.</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>
<var>robustness</var>
</p>

</td><td align="left" valign="top">
<p>
<tt>PTHREAD_MUTEX_STALLED_NP</tt>
</p>

</td><td align="left" valign="top">
<p>When the owner of a mutex dies, all future   calls to <kbd><b>pthread_mutex_lock()</b></kbd> for this mutex will be blocked from progress.</p>

</td>
</tr>

</tbody>
</table>
<p> 
</p><a name="6mba5vpsv"></a><h3 class="sol">
<tt>pthread_mutexattr_init</tt> Return
Values</h3>
<p>
<a name="indexterm-86"></a><kbd><b>pthread_mutexattr_init()</b></kbd> returns
zero after completing successfully. Any other return value indicates that
an error occurred. If either of the following conditions occurs, the function
fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>ENOMEM</samp></tt>
</p>

<b>Description: </b>
<p>Insufficient memory exists to initialize
the mutex attribute object.</p>


</dl><a name="6mba5vpt1"></a><h2 class="sol">Destroying a Mutex Attribute Object</h2>
<p>
<a name="indexterm-87"></a><a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutexattr-destroy-3c/index.html">pthread_mutexattr_destroy(3C)</a> deallocates
the storage space used to maintain the attribute object created by <kbd><b>pthread_mutexattr_init()</b></kbd>.</p>
<a name="6mba5vpt3"></a><h3 class="sol">
<tt>pthread_mutexattr_destroy</tt> Syntax</h3>
<a name="sync-ix287"></a><a name=""></a><pre>int pthread_mutexattr_destroy(pthread_mutexattr_t *<var>mattr)</var>
</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt; 
pthread_mutexattr_t <var>mattr</var>; 
int <var>ret</var>; 
/* destroy an attribute */ 
<var>ret</var> = pthread_mutexattr_destroy(&amp;<var>mattr</var>); </pre>
<a name="6mba5vpt5"></a><h3 class="sol">
<tt>pthread_mutexattr_destroy</tt> Return
Values</h3>
<p>
<a name="indexterm-88"></a><kbd><b>pthread_mutexattr_destroy()</b></kbd> returns zero after completing successfully. Any other return value
indicates that an error occurred. If the following condition occurs, the function
fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>mattr</var> is
invalid.</p>


</dl><a name="6mba5vpt7"></a><h2 class="sol">Setting the Scope of a Mutex</h2>
<p>
<a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutexattr-setpshared-3c/index.html">pthread_mutexattr_setpshared(3C)</a> sets the scope of the mutex variable.</p>
<a name="6mba5vpt9"></a><h3 class="sol">
<tt>pthread_mutexattr_setpshared</tt> Syntax</h3>
<a name="sync-ix289"></a><a name=""></a><pre>int pthread_mutexattr_setpshared(pthread_mutexattr_t *restrict <var>mattr</var>,
         int *restrict <var>pshared</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt; 
pthread_mutexattr_t <var>mattr</var>; 
int <var>ret</var>; 
<var>ret</var> = pthread_mutexattr_init(&amp;<var>mattr</var>); 
/* * resetting to its default value: private */ 
<var>ret</var> = pthread_mutexattr_setpshared(&amp;<var>mattr</var>, PTHREAD_PROCESS_PRIVATE);</pre>
<p>
<a name="sync-ix290"></a>The
scope of a mutex variable can be either process private (intraprocess) or
system wide (interprocess). To share the mutex among threads from more than
one process, create the mutex in shared memory with the <var>pshared</var> attribute
set to <tt>PTHREAD_PROCESS_SHARED</tt> . </p>
<p>If the mutex <var>pshared</var> attribute is set to <tt>PTHREAD_PROCESS_PRIVATE</tt> , only those threads created by the same
process can operate on the mutex.</p>
<a name="6mba5vptb"></a><h3 class="sol">
<tt>pthread_mutexattr_setpshared</tt> Return
Values</h3>
<p>
<a name="indexterm-89"></a><kbd><b>pthread_mutexattr_setpshared()</b></kbd>  returns zero after completing successfully. Any other return
value indicates that an error occurred. If the following condition occurs,
the function fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>mattr</var> is
invalid.</p>


</dl><a name="6mba5vptd"></a><h2 class="sol">Getting the Scope of a Mutex</h2>
<p>
<a name="indexterm-90"></a><a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutexattr-getpshared-3c/index.html">pthread_mutexattr_getpshared(3C)</a> returns the
scope of the mutex variable defined by  <kbd><b>pthread_mutexattr_setpshared()</b></kbd>.</p>
<a name="6mba5vptf"></a><h3 class="sol">
<tt>pthread_mutexattr_getpshared</tt> Syntax</h3>
<a name="sync-ix294"></a><a name=""></a><pre>int pthread_mutexattr_getpshared(pthread_mutexattr_t *restrict <var>mattr</var>, 
          int *restrict <var>pshared</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt; 
pthread_mutexattr_t <var>mattr</var>; 
int <var>pshared</var>, <var>ret</var>; 
/* get pshared of mutex */ 
<var>ret</var> = pthread_mutexattr_getpshared(&amp;<var>mattr</var>, &amp;<var>pshared</var>); </pre>
<p>Get the current value of <var>pshared</var> for the
attribute object <var>mattr</var>. The value is either <tt>PTHREAD_PROCESS_SHARED</tt>  or <tt>PTHREAD_PROCESS_PRIVATE</tt>.</p>
<a name="6mba5vpth"></a><h3 class="sol">
<tt>pthread_mutexattr_getpshared</tt> Return
Values</h3>
<p>
<a name="indexterm-91"></a><kbd><b>pthread_mutexattr_getpshared()</b></kbd>  returns zero after completing successfully. Any other return
value indicates that an error occurred. If the following condition occurs,
the function fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>mattr</var> is
invalid.</p>


</dl><a name="6mba5vptj"></a><h2 class="sol">Setting the Mutex Type Attribute</h2>
<p>
<a name="indexterm-92"></a><a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutexattr-settype-3c/index.html">pthread_mutexattr_settype(3C)</a> sets the
mutex <var>type</var> attribute.</p>
<a name="6mba5vptl"></a><h3 class="sol">
<tt>pthread_mutexattr_settype</tt> Syntax</h3>
<a name=""></a><pre>#include &lt;pthread.h&gt;

int pthread_mutexattr_settype(pthread_mutexattr_t  *<var>attr</var> , int <var>type</var>);</pre>
<p>
<a name="indexterm-93"></a>The default value of the <var>type</var> attribute
is  <tt>PTHREAD_MUTEX_DEFAULT</tt>.</p>
<p>The <var>type</var> argument specifies the type of mutex.
The following list describes the valid mutex types:</p>
<dl>
<br>
<p>
<tt>PTHREAD_MUTEX_NORMAL</tt>
</p>

<b>Description: </b>
<p>This type of mutex does not detect deadlock.
A thread attempting to relock this mutex without first unlocking the mutex
deadlocks. Attempting to unlock a mutex locked by a different thread results
in undefined behavior. Attempting to unlock an unlocked mutex results in undefined
behavior.</p>


</dl><dl>
<br>
<p>
<tt>PTHREAD_MUTEX_ERRORCHECK</tt>
</p>

<b>Description: </b>
<p>This type of mutex provides error checking.
A thread attempting to relock this mutex without first unlocking the mutex
returns an error. A thread attempting to unlock a mutex that another thread
has locked returns an error. A thread attempting to unlock an unlocked mutex
returns an error.</p>


</dl><dl>
<br>
<p>
<tt>PTHREAD_MUTEX_RECURSIVE</tt>
</p>

<b>Description: </b>
<p>A thread attempting to relock this mutex
without first unlocking the mutex succeeds in locking the mutex. The relocking
deadlock that can occur with mutexes of type <tt>PTHREAD_MUTEX_NORMAL</tt> cannot
occur with this type of mutex. Multiple locks of this mutex require the same
number of unlocks to release the mutex before another thread can acquire the
mutex. A thread attempting to unlock a mutex that another thread has locked
returns an error. A thread attempting to unlock an unlocked mutex returns
an error.</p>


</dl><dl>
<br>
<p>
<tt>PTHREAD_MUTEX_DEFAULT</tt>
</p>

<b>Description: </b>
<p>An implementation is allowed to map this
attribute to one of the other mutex types. The Solaris implementation maps
this attribute to <tt>PTHREAD_PROCESS_NORMAL</tt>.</p>


</dl><a name="6mba5vptn"></a><h3 class="sol">
<tt>pthread_mutexattr_settype</tt> Return
Values</h3>
<p>
<a name="indexterm-94"></a>If successful, the <kbd>pthread_mutexattr_settype</kbd>  function returns zero. Otherwise, an error number is returned
to indicate the error.</p>
<dl>
<br>
<p>
<tt>EINVAL</tt>
</p>

<b>Description: </b>
<p>The value <var>type</var> or <var>attr</var> is invalid.</p>


</dl><a name="6mba5vptp"></a><h2 class="sol">Getting the Mutex Type Attribute</h2>
<p>
<a name="indexterm-95"></a><a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutexattr-gettype-3c/index.html">pthread_mutexattr_gettype(3C)</a> gets the
mutex <var>type</var> attribute set by  <kbd><b>pthread_mutexattr_settype()</b></kbd>.</p>
<a name="6mba5vptr"></a><h3 class="sol">
<tt>pthread_mutexattr_gettype</tt> Syntax</h3>
<a name=""></a><pre>#include &lt;pthread.h&gt;

int pthread_mutexattr_gettype(pthread_mutexattr_t  *restrict <var>attr</var> , 
int  *restrict <var>type</var>);</pre>
<p>The default value of the <var>type</var> attribute is <tt>PTHREAD_MUTEX_DEFAULT</tt>.</p>
<p>The <var>type</var> argument specifies the type of mutex.
Valid mutex types include</p>
<a name=""></a><ul>
<li>
<p>
<tt>PTHREAD_MUTEX_NORMAL</tt>
</p>


</li>
<li>
<p>
<tt>PTHREAD_MUTEX_ERRORCHECK</tt>
</p>


</li>
<li>
<p>
<tt>PTHREAD_MUTEX_RECURSIVE</tt>
</p>


</li>
<li>
<p>
<tt>PTHREAD_MUTEX_DEFAULT</tt>
</p>


</li>
</ul>
<p>For a description of each type, see <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-75/index.html"><tt>pthread_mutexattr_settype</tt> Syntax</a>.</p>
<a name="6mba5vptt"></a><h3 class="sol">
<tt>pthread_mutexattr_gettype</tt> Return
Values</h3>
<p>
<a name="indexterm-96"></a>On successful completion, <kbd><b>pthread_mutexattr_gettype()</b></kbd>  returns 0. Any other return value indicates
that an error occurred.</p>
<dl>
<br>
<p>
<tt>EINVAL</tt>
</p>

<b>Description: </b>
<p>The value specified by <var>type</var> is
invalid.</p>


</dl><a name="6mba5vptv"></a><h2 class="sol">Setting the Mutex Attribute's Protocol</h2>
<p>
<a name="indexterm-97"></a><a name="indexterm-98"></a><a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutexattr-setprotocol-3c/index.html">pthread_mutexattr_setprotocol(3C)</a> sets the
protocol attribute of a mutex attribute object.</p>
<a name="6mba5vpu1"></a><h3 class="sol">
<tt>pthread_mutexattr_setprotocol</tt> Syntax</h3>
<a name=""></a><pre>#include &lt;pthread.h&gt; 
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *<var>attr</var>, 
          int <var>protocol</var>);</pre>
<p>
<var>attr</var> points to a mutex attribute object created
by an earlier call to <kbd><b>pthread_mutexattr_init()</b></kbd>.</p>
<p>
<var>protocol</var> defines the protocol that is applied
to the mutex attribute object.</p>
<p>The value of <var>protocol</var> that is defined in
 <kbd>pthread.h</kbd> can be one of the following values: <tt>PTHREAD_PRIO_NONE</tt> , <tt>PTHREAD_PRIO_INHERIT</tt>, or <tt>PTHREAD_PRIO_PROTECT</tt> .</p>
<a name=""></a><ul>
<li>
<p>
<tt>PTHREAD_PRIO_NONE</tt>
</p>

<p>
<a name="indexterm-99"></a>A thread's
priority and scheduling are not affected by the mutex ownership.</p>


</li>
<li>
<p>
<tt>PTHREAD_PRIO_INHERIT</tt>
</p>

<p>
<a name="indexterm-100"></a>This
protocol value affects an owning thread's priority and scheduling. When higher-priority
threads block on one or more mutexes owned by <tt>thrd1</tt> where
those mutexes are initialized with <tt>PTHREAD_PRIO_INHERIT</tt>, <tt>thrd1</tt>  runs with the higher of its priority or the highest priority
of any thread waiting on any of the mutexes owned by <tt>thrd1</tt>.</p>

<p>If  <tt>thrd1</tt> blocks on a mutex owned by another thread, <tt>thrd3</tt>, the same priority inheritance effect recursively propagates
to <tt>thrd3</tt>.</p>

<p>
<a name="indexterm-101"></a>Use  <tt>PTHREAD_PRIO_INHERIT</tt> to avoid priority inversion. Priority inversion occurs when a low-priority
thread holds a lock that a higher-priority thread requires. The higher-priority
thread cannot continue until the lower-priority thread releases the lock. </p>

<p>Without priority inheritance, the lower priority thread might not be
scheduled to run for a long time, causing the higher priority thread to block
equally long. Priority inheritance temporarily raises the priority of the
lower priority thread so it will be scheduled to run quickly and release the
lock, allowing the higher priority thread to acquire it. The lower-priority
thread reverts to its lower priority when it releases the lock.</p>


</li>
<li>
<p>
<tt>PTHREAD_PRIO_PROTECT</tt>
</p>

<p>
<a name="indexterm-102"></a>This
protocol value affects the priority and scheduling of a thread, such as <tt>thrd2</tt>, when the thread owns one or more mutexes that are initialized
with <tt>PTHREAD_PRIO_PROTECT</tt>.  <tt>thrd2</tt> runs
with the higher of its priority or the highest-priority ceiling of all mutexes
owned by <tt>thrd2</tt>. Higher-priority threads blocked on any
of the mutexes, owned by <tt>thrd2</tt>, have no effect on the scheduling
of <tt>thrd2</tt>.</p>


</li>
</ul>
<p>The <tt>PTHREAD_PRIO_INHERIT</tt> and <tt>PTHREAD_PRIO_PROTECT</tt> mutex attributes are usable only by privileged processes running
in the realtime (RT) scheduling class <tt>SCHED_FIFO</tt> or <tt>SCHED_RR</tt>.</p>
<p>A thread can simultaneously own several mutexes initialized with a mix
of  <tt>PTHREAD_PRIO_INHERIT</tt> and <tt>PTHREAD_PRIO_PROTECT</tt>.
In this case, the thread executes at the highest priority obtained by either
of these protocols.</p>
<a name="6mba5vpu3"></a><h3 class="sol">
<tt>pthread_mutexattr_setprotocol</tt> Return
Values</h3>
<p>
<a name="indexterm-103"></a>On successful completion,
 <kbd><b>pthread_mutexattr_setprotocol()</b></kbd> returns 0. Any other return
value indicates that an error occurred.</p>
<p>If either of the following conditions occurs, <kbd><b>pthread_mutexattr_setprotocol()</b></kbd>  might fail and return the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>attr</var> or
 <var>protocol</var> is not valid.</p>


<br>
<p>
<tt><samp>EPERM</samp></tt>
</p>

<b>Description: </b>
<p>The caller does not have the privilege
to perform the operation.</p>


</dl><a name="6mba5vpu5"></a><h2 class="sol">Getting the Mutex Attribute's Protocol</h2>
<p>
<a name="indexterm-104"></a><a name="indexterm-105"></a><a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutexattr-getprotocol-3c/index.html">pthread_mutexattr_getprotocol(3C)</a> gets the
protocol attribute of a mutex attribute object.</p>
<a name="6mba5vpu7"></a><h3 class="sol">
<tt>pthread_mutexattr_getprotocol</tt> Syntax</h3>
<a name=""></a><pre>#include &lt;pthread.h&gt; 
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict <var>attr</var>, 
int *restrict <var>protocol</var>);</pre>
<p>
<var>attr</var> points to a mutex attribute object created
by an earlier call to <kbd><b>pthread_mutexattr_init()</b></kbd>.</p>
<p>
<var>protocol</var> contains one of the following protocol
attributes:  <tt>PTHREAD_PRIO_NONE</tt>, <tt>PTHREAD_PRIO_INHERIT</tt>,
or  <tt>PTHREAD_PRIO_PROTECT</tt> which are defined by the header <tt>&lt;pthread.h&gt;</tt>.</p>
<a name="6mba5vpu9"></a><h3 class="sol">
<tt>pthread_mutexattr_getprotocol</tt> Return
Values</h3>
<p>
<a name="indexterm-106"></a>On successful completion,
 <kbd><b>pthread_mutexattr_getprotocol()</b></kbd> returns 0. Any other return
value indicates that an error occurred.</p>
<p>If either of the following conditions occurs, <kbd><b>pthread_mutexattr_getprotocol()</b></kbd>  might fail and return the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>attr</var> is
NULL, or the value specified by <var>attr</var> or <var>protocol</var> is invalid.</p>


<br>
<p>
<tt><samp>EPERM</samp></tt>
</p>

<b>Description: </b>
<p>The caller does not have the privilege
to perform the operation.</p>


</dl><a name="6mba5vpub"></a><h2 class="sol">Setting the Mutex Attribute's Priority Ceiling</h2>
<p>
<a name="indexterm-107"></a><a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutexattr-setprioceiling-3c/index.html">pthread_mutexattr_setprioceiling(3C)</a> sets the
priority ceiling attribute of a mutex attribute object.</p>
<a name="6mba5vpud"></a><h3 class="sol">
<tt>pthread_mutexattr_setprioceiling</tt> Syntax</h3>
<a name=""></a><pre>#include &lt;pthread.h&gt; 
int pthread_mutexattr_setprioceiling(pthread_mutexatt_t *<var>attr</var>, int <var>prioceiling</var>);</pre>
<p>
<var>attr</var> points to a mutex attribute object created
by an earlier call to <kbd><b>pthread_mutexattr_init()</b></kbd>.</p>
<p>
<a name="indexterm-108"></a><var>prioceiling</var> specifies the priority ceiling of initialized mutexes. The
ceiling defines the minimum priority level at which the critical section guarded
by the mutex is executed.  <var>prioceiling</var> falls within
the maximum range of priorities defined by  <tt>SCHED_FIFO</tt>.
To avoid priority inversion, set <var>prioceiling</var> to
a priority higher than or equal to the highest priority of all threads that
might lock the particular mutex.</p>
<a name="6mba5vpuf"></a><h3 class="sol">
<tt>pthread_mutexattr_setprioceiling</tt> Return
Values</h3>
<p>
<a name="indexterm-109"></a>On successful completion,
 <kbd><b>pthread_mutexattr_setprioceiling()</b></kbd> returns 0. Any other
return value indicates that an error occurred.</p>
<p>If either of the following conditions occurs, <kbd><b>pthread_mutexattr_setprioceiling()</b></kbd>  might fail and return the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>attr</var> is
NULL or invalid or  <var>prioceiling</var> is invalid.</p>


<br>
<p>
<tt><samp>EPERM</samp></tt>
</p>

<b>Description: </b>
<p>The caller does not have the privilege
to perform the operation.</p>


</dl><a name="6mba5vpuh"></a><h2 class="sol">Getting the Mutex Attribute's Priority Ceiling</h2>
<p>
<a name="indexterm-110"></a><a name="indexterm-111"></a><a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutexattr-getprioceiling-3c/index.html">pthread_mutexattr_getprioceiling(3C)</a> gets the
priority ceiling attribute of a mutex attribute object.</p>
<a name="6mba5vpuj"></a><h3 class="sol">
<tt>pthread_mutexattr_getprioceiling</tt> Syntax</h3>
<a name=""></a><pre>#include &lt;pthread.h&gt; 
int pthread_mutexattr_getprioceiling(const pthread_mutexatt_t *restrict <var>attr</var>, 
           int *restrict <var>prioceiling</var>);</pre>
<p>
<var>attr</var> designates the attribute object created
by an earlier call to <kbd><b>pthread_mutexattr_init()</b></kbd>.</p>
<p>
<kbd><b>pthread_mutexattr_getprioceiling()</b></kbd> returns the priority
ceiling of initialized mutexes in <var>prioceiling</var>.
The ceiling defines the minimum priority level at which the critical section
guarded by the mutex is executed.  <var>prioceiling</var> falls
within the maximum range of priorities defined by  <tt>SCHED_FIFO</tt>.
To avoid priority inversion, set <var>prioceiling</var> to
a priority higher than or equal to the highest priority of all threads that
might lock the particular mutex.</p>
<a name="6mba5vpul"></a><h3 class="sol">
<tt>pthread_mutexattr_getprioceiling</tt> Return
Values</h3>
<p>
<a name="indexterm-112"></a>On successful completion,
 <kbd><b>pthread_mutexattr_getprioceiling()</b></kbd> returns 0. Any other
return value indicates that an error occurred.</p>
<p>If either of the following conditions occurs, <kbd><b>pthread_mutexattr_getprioceiling()</b></kbd>  might fail and return the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>attr</var> is
NULL.</p>


<br>
<p>
<tt><samp>EPERM</samp></tt>
</p>

<b>Description: </b>
<p>The caller does not have the privilege
to perform the operation.</p>


</dl><a name="6mba5vpun"></a><h2 class="sol">Setting the Mutex's Priority Ceiling</h2>
<p>
<a name="indexterm-113"></a><a name="indexterm-114"></a><a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutexattr-setprioceiling-3c/index.html">pthread_mutexattr_setprioceiling(3C)</a> sets the
priority ceiling of a mutex.</p>
<a name="6mba5vpup"></a><h3 class="sol">
<tt>pthread_mutex_setprioceiling</tt> Syntax</h3>
<a name=""></a><pre>#include &lt;pthread.h&gt; 
int pthread_mutex_setprioceiling(pthread_mutex_t *restrict <var>mutex</var>, 
          int <var>prioceiling</var>, int *restrict <var>old_ceiling</var>);</pre>
<p>
<kbd><b>pthread_mutex_setprioceiling()</b></kbd> changes the priority
ceiling,  <var>prioceiling</var>, of a mutex, <var>mutex</var>.
 <kbd><b>pthread_mutex_setprioceiling()</b></kbd> locks a mutex if unlocked,
or blocks until  <kbd><b>pthread_mutex_setprioceiling()</b></kbd> successfully
locks the mutex, changes the priority ceiling of the mutex and releases the
mutex. The process of locking the mutex need not adhere to the priority protect
protocol.</p>
<p>If <kbd><b>pthread_mutex_setprioceiling()</b></kbd> succeeds, the previous
value of the priority ceiling is returned in <var>old_ceiling</var>.
If <kbd><b>pthread_mutex_setprioceiling()</b></kbd> fails, the mutex priority
ceiling remains unchanged.</p>
<a name="6mba5vpur"></a><h3 class="sol">
<tt>pthread_mutex_setprioceiling</tt> Return
Values</h3>
<p>
<a name="indexterm-115"></a>On successful completion,
 <kbd><b>pthread_mutex_setprioceiling()</b></kbd> returns 0. Any other return
value indicates that an error occurred.</p>
<p>If any of the following conditions occurs, <kbd><b>pthread_mutex_setprioceiling()</b></kbd>  might fail and return the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The priority requested by <var>prioceiling</var>  is out of range.</p>


<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The mutex was not initialized with its <var>protocol</var> attribute having the value of <tt>THREAD_PRIO_PROTECT</tt>.</p>


<br>
<p>
<tt><samp>EPERM</samp></tt>
</p>

<b>Description: </b>
<p>The caller does not have the privilege
to perform the operation.</p>


</dl><a name="6mba5vput"></a><h2 class="sol">Getting the Mutex's Priority Ceiling</h2>
<p>
<a name="indexterm-116"></a><a name="indexterm-117"></a><a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutexattr-getprioceiling-3c/index.html">pthread_mutexattr_getprioceiling(3C)</a> gets the
priority ceiling of a mutex.</p>
<a name="6mba5vpuv"></a><h3 class="sol">
<tt>pthread_mutex_getprioceiling</tt> Syntax</h3>
<a name=""></a><pre>#include &lt;pthread.h&gt; 
int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict <var>mutex</var>, 
          int *restrict <var>prioceiling</var>);</pre>
<p>
<kbd><b>pthread_mutex_getprioceiling()</b></kbd> returns the priority
ceiling,  <var>prioceiling</var> of a <var>mutex</var>.</p>
<a name="6mba5vpv1"></a><h3 class="sol">
<tt>pthread_mutex_getprioceiling</tt> Return
Values</h3>
<p>
<a name="indexterm-118"></a>On successful completion,
 <kbd><b>pthread_mutex_getprioceiling()</b></kbd> returns 0. Any other return
value indicates that an error occurred.</p>
<p>If any of the following conditions occurs, <kbd><b>pthread_mutexatt_getprioceiling()</b></kbd>  fails and returns the corresponding value.</p>
<p>If any of the following conditions occurs, <kbd><b>pthread_mutex_getprioceiling()</b></kbd>  might fail and return the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>mutex</var> does
not refer to a currently existing mutex.</p>


<br>
<p>
<tt><samp>EPERM</samp></tt>
</p>

<b>Description: </b>
<p>The caller does not have the privilege
to perform the operation.</p>


</dl><a name="6mba5vpv3"></a><h2 class="sol">Setting the Mutex's Robust Attribute</h2>
<p>
<a name="indexterm-119"></a><a name="indexterm-120"></a><a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutexattr-setrobust-np-3c/index.html">pthread_mutexattr_setrobust_np(3C)</a> sets the robust attribute of a mutex attribute object.</p>
<a name="6mba5vpv5"></a><h3 class="sol">
<tt>pthread_mutexattr_setrobust_np</tt> Syntax</h3>
<a name=""></a><pre>#include &lt;pthread.h&gt; 
int pthread_mutexattr_setrobust_np(pthread_mutexattr_t *<var>attr</var>, int *<var>robustness</var>);</pre>
<hr><b>Note – </b><p>
<kbd><b>pthread_mutexattr_setrobust_np()</b></kbd> applies only
if the symbol <tt>_POSIX_THREAD_PRIO_INHERIT</tt> is defined.</p>
<p>In the Solaris 10 and prior releases, the <tt>PTHREAD_MUTEX_ROBUST_NP</tt> attribute
can only be applied to mutexes that are also marked with the <tt>PTHREAD_PRIO_INHERIT</tt> protocol attribute.  This restriction is lifted in subsequent Solaris
releases.</p>
<hr>
<p>
<var>attr</var> points to the mutex attribute object
previously created by a call to <kbd><b>pthread_mutexattr_init()</b></kbd>.</p>
<p>
<var>robustness</var> defines the behavior when the
owner of the mutex terminates without unlocking the mutex, usually because
its process terminated abnormally. The value of <var>robustness</var> that
is defined in <kbd>pthread.h</kbd> is <tt>PTHREAD_MUTEX_ROBUST_NP</tt> or
 <tt>PTHREAD_MUTEX_STALLED_NP</tt>. The default value is <tt>PTHREAD_MUTEX_STALLED_NP</tt> .</p>
<a name=""></a><ul>
<li>
<p>
<tt>PTHREAD_MUTEX_STALLED_NP</tt>
</p>

<p>When
the owner of the mutex terminates without unlocking the mutex, all subsequent
calls to <kbd><b>pthread_mutex_lock()</b></kbd> are blocked from progress
in an unspecified manner.</p>


</li>
<li>
<p>
<tt>PTHREAD_MUTEX_ROBUST_NP</tt>
</p>

<p>When
the owner of the mutex terminates without unlocking the mutex, the mutex is
unlocked. The next owner of this mutex acquires the mutex with an error return
of <samp>EOWNERDEAD</samp>.</p>

<hr>
<b>Note – </b>
<p>Your application must always check the return code from <kbd><b>pthread_mutex_lock()</b></kbd> for a mutex initialized with the <tt>PTHREAD_MUTEX_ROBUST_NP</tt> attribute.</p>

<hr>

<a name=""></a>
<ul>
<li>
<p>The new owner of this mutex should make the state protected
by the mutex consistent. This state might have been left inconsistent when
the previous owner terminated.</p>


</li>
<li>
<p>If the new owner is able to make the state consistent, call <kbd><b>pthread_mutex_consistent_np()</b></kbd> for the mutex before unlocking the
mutex. This marks the mutex as consistent and subsequent calls to <kbd><b>pthread_mutex_lock()</b></kbd> and <kbd><b>pthread_mutex_unlock()</b></kbd> will behave in the
normal manner.</p>


</li>
<li>
<p>If the new owner is <b>not</b> able to make
the state consistent, do <b>not</b> call <kbd><b>pthread_mutex_consistent_np()</b></kbd>  for the mutex, but unlock the mutex.</p>

<p>All waiters
are woken up and all subsequent calls to <kbd><b>pthread_mutex_lock()</b></kbd> fail
to acquire the mutex. The return code is <samp>ENOTRECOVERABLE</samp>.
The mutex can be made consistent by calling <kbd><b>pthread_mutex_destroy()</b></kbd> to
uninitialize the mutex, and calling <kbd><b>pthread_mutex_int()</b></kbd> to
reinitialize the mutex. However, the state that was protected by the mutex
remains inconsistent and some form of application recovery is required.</p>


</li>
</ul>

<p>If the thread that acquires the lock with <samp>EOWNERDEAD</samp> terminates
without unlocking the mutex, the next owner acquires the lock with an <samp>EOWNERDEAD</samp> return code.</p>


</li>
</ul>
<a name="6mba5vpv7"></a><h3 class="sol">
<tt>pthread_mutexattr_setrobust_np</tt> Return
Values</h3>
<p>
<a name="indexterm-121"></a>On successful completion,  <kbd><b>pthread_mutexattr_setrobust_np()</b></kbd> returns 0. Any other return value
indicates that an error occurred.</p>
<p>
<kbd><b>pthread_mutexattr_setrobust_np()</b></kbd> might fail if the
following condition occurs:</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>attr</var> or
 <var>robustness</var> is invalid.</p>


</dl><a name="6mba5vpv9"></a><h2 class="sol">Getting the Mutex's Robust Attribute</h2>
<p>
<a name="indexterm-122"></a><a name="indexterm-123"></a><a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutexattr-getrobust-np-3c/index.html">pthread_mutexattr_getrobust_np(3C)</a> gets the robust attribute of a mutex attribute object.</p>
<a name="6mba5vpvb"></a><h3 class="sol">
<tt>pthread_mutexattr_getrobust_np</tt> Syntax</h3>
<a name=""></a><pre>#include &lt;pthread.h&gt; 
int pthread_mutexattr_getrobust_np(const pthread_mutexattr_t *<var>attr</var>, int *<var>robustness</var>);</pre>
<p>
<var>attr</var> points to the mutex attribute object
previously created by a call to <kbd><b>pthread_mutexattr_init()</b></kbd>.</p>
<p>
<var>robustness</var> is the value of the robust attribute
of a mutex attribute object.</p>
<a name="6mba5vpvd"></a><h3 class="sol">
<tt>pthread_mutexattr_getrobust_np</tt> Return
Values</h3>
<p>
<a name="indexterm-124"></a>On successful completion,
 <kbd><b>pthread_mutexattr_getrobust_np()</b></kbd> returns 0. Any other
return value indicates that an error occurred.</p>
<p>
<kbd><b>pthread_mutexattr_getrobust_np()</b></kbd> might fail if the
following condition occurs:</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>attr</var> or
 <var>robustness</var> is invalid.</p>


</dl><a name="6mba5vpvf"></a><h1 class="sol">Using Mutual Exclusion Locks</h1>
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vpvf/index.html#sync-tbl-12">Table 4–3</a> lists the
functions that manipulate mutex locks.</p>
<a name="sync-tbl-12"></a>Table 4–3  Routines for Mutual Exclusion
Locks<table width="100%" cellpadding="10" cellspacing="0" border="2">
<caption>
<b></b>
</caption>
<thead>
<tr>
<th scope="col" align="left" valign="top">
<p>Operation&nbsp;</p>

</th><th scope="col" align="left" valign="top">
<p>Related Function Description&nbsp;</p>

</th>
</tr>

</thead>
<tbody>
<tr>
<td align="left" valign="top">
<p>Initialize a mutex&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-113/index.html"><tt>pthread_mutex_init</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Make mutex consistent&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-116/index.html"><tt>pthread_mutex_consistent_np</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Lock a mutex&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-117/index.html"><tt>pthread_mutex_lock</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Unlock a mutex&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-61163/index.html"><tt>pthread_mutex_unlock</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Lock with a nonblocking mutex&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-24727/index.html"><tt>pthread_mutex_trylock</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Lock a mutex before a specified time&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/gfwkh/index.html"><kbd><b>pthread_mutex_timedlock()</b></kbd> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Lock a mutex within a specified time interval&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/gfwje/index.html"><kbd><b>pthread_mutex_reltimedlock_np()</b></kbd> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Destroy a mutex&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-20140/index.html"><tt>pthread_mutex_destroy</tt> Syntax</a>
</p>

</td>
</tr>

</tbody>
</table>
<p> 
</p><p>The default scheduling policy, <tt>SCHED_OTHER</tt>, does
not specify the order in which threads can acquire a lock. When multiple <tt>SCHED_OTHER</tt> threads are waiting for a mutex, the order of acquisition
is undefined. Under the <tt>SCHED_FIFO</tt> and <tt>SCHED_RR</tt> real-time
scheduling policies, the behavior is to unblock waiting threads in priority
order.</p>
<a name="6mba5vpvh"></a><h2 class="sol">Initializing a Mutex</h2>
<p>
<a name="indexterm-125"></a><a name="indexterm-126"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutex-init-3c/index.html">pthread_mutex_init(3C)</a> to initialize the mutex pointed at by <var>mp</var> to
its default value or to specify mutex attributes that have already been set
with <kbd><b>pthread_mutexattr_init()</b></kbd> . The default value for <var>mattr</var> is <tt>NULL</tt> .</p>
<a name="6mba5vpvj"></a><h3 class="sol">
<tt>pthread_mutex_init</tt> Syntax</h3>
<a name="indexterm-127"></a><a name=""></a><pre>int pthread_mutex_init(pthread_mutex_t *restrict <var>mp</var>,
          const pthread_mutexattr_t *restrict <var>mattr</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;

pthread_mutex_t <var>mp</var> = PTHREAD_MUTEX_INITIALIZER;
pthread_mutexattr_t <var>mattr</var>;
int <var>ret</var>;

/* initialize a mutex to its default value */
<var>ret</var> = pthread_mutex_init(&amp;<var>mp</var>, NULL);

/* initialize a mutex */
<var>ret</var> = pthread_mutex_init(&amp;<var>mp</var>, &amp;<var>mattr</var>); </pre>
<p>When the mutex is initialized, the mutex is in an unlocked state. The
mutex can be in memory that is shared between processes or in memory private
to a process.</p>
<hr><b>Note – </b><p>For a mutex that is being initialized with the <tt>PTHREAD_MUTEX_ROBUST_NP</tt> attribute, the mutex memory must be cleared to zero before initialization.</p>
<hr>
<p>The effect of <var>mattr</var> set to <tt>NULL</tt> is
the same as passing the address of a default mutex attribute object, but without
the memory overhead.</p>
<p>Use the macro <tt>PTHREAD_MUTEX_INITIALIZER</tt> to initialize
statically defined mutexes to their default attributes.</p>
<p>Do not reinitialize or destroy a mutex lock while other threads are
using the mutex. Program failure results if either action is not done correctly.
If a mutex is reinitialized or destroyed, the application must be sure the
mutex is not currently in use.</p>
<a name="6mba5vpvl"></a><h3 class="sol">
<tt>pthread_mutex_init</tt> Return Values</h3>
<p>
<a name="indexterm-128"></a><kbd><b>pthread_mutex_init()</b></kbd> returns
zero after completing successfully. Any other return value indicates that
an error occurred. When any of the following conditions occurs, the function
fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EBUSY</samp></tt>
</p>

<b>Description: </b>
<p>The implementation has detected an attempt
to reinitialize the object referenced by <var>mp</var>, a
previously initialized but not yet destroyed mutex.</p>


</dl><dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The <var>mattr</var> attribute
value is invalid. The mutex has not been modified.</p>


</dl><dl>
<br>
<p>
<tt><samp>EFAULT</samp></tt>
</p>

<b>Description: </b>
<p>The address for the mutex pointed at by
 <var>mp</var> is invalid.</p>


</dl><a name="6mba5vpvn"></a><h2 class="sol">Making a Mutex Consistent</h2>
<p>If the owner of a robust mutex terminates without unlocking the mutex,
the mutex is unlocked and marked inconsistent. The next owner acquires the
lock with an <samp>EOWNERDEAD</samp> return code.</p>
<p>
<a name="indexterm-129"></a><kbd><b>pthread_mutex_consistent_np()</b></kbd> makes
the mutex object, <var>mutex</var>, consistent after the death
of its owner.</p>
<a name="6mba5vpvp"></a><h3 class="sol">
<tt>pthread_mutex_consistent_np</tt> Syntax</h3>
<a name="indexterm-130"></a><a name=""></a><pre>#include &lt;pthread.h&gt; 
int pthread_mutex_consistent_np(pthread_mutex_t *<var>mutex</var>); </pre>
<p>Call <kbd><b>pthread_mutex_lock()</b></kbd> to acquire the inconsistent
mutex. The <tt>EOWNWERDEAD</tt> return value indicates an inconsistent
mutex.</p>
<p>Call <kbd><b>pthread_mutex_consistent_np()</b></kbd> while holding
the mutex acquired by a previous call to <kbd><b>pthread_mutex_lock()</b></kbd>.</p>
<p>The critical section protected by the mutex might have been left in
an inconsistent state by a failed owner. In this case, make the mutex consistent
only if you can make the critical section protected by the mutex consistent.</p>
<p>Calls to <kbd><b>pthread_mutex_lock()</b></kbd>, <kbd><b>pthread_mutex_unlock()</b></kbd> , and <kbd><b>pthread_mutex_trylock()</b></kbd> for a consistent
mutex behave in the normal manner.</p>
<p>The behavior of <kbd><b>pthread_mutex_consistent_np()</b></kbd> for
a mutex that is <b>not</b> inconsistent, or is not held, is
undefined.</p>
<a name="6mba5vpvr"></a><h3 class="sol">
<tt>pthread_mutex_consistent_np</tt> Return
Values</h3>
<p>
<a name="indexterm-131"></a><kbd><b>pthread_mutex_consistent_np()</b></kbd>  returns zero after completing successfully. Any other return
value indicates that an error occurred.</p>
<p>
<kbd><b>pthread_mutex_consistent_np()</b></kbd> fails if the following
condition occurs:</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The current thread does not own the mutex
or the mutex is not a <tt>PTHREAD_MUTEX_ROBUST_NP</tt> mutex having
an inconsistent state.</p>


</dl><a name="6mba5vpvt"></a><h2 class="sol">Locking a Mutex</h2>
<p>
<a name="indexterm-132"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutex-lock-3c/index.html">pthread_mutex_lock(3C)</a> to lock the mutex pointed to by <var>mutex</var>.</p>
<a name="6mba5vpvv"></a><h3 class="sol">
<tt>pthread_mutex_lock</tt> Syntax</h3>
<a name="indexterm-133"></a><a name=""></a><pre>int  pthread_mutex_lock(pthread_mutex_t *<var>mutex</var>); </pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;

pthread_mutex_t <var>mutex</var>;
int <var>ret</var>;

<var>ret</var> = pthread_ mutex_lock(&amp;<var>mp</var>); /* acquire the mutex */</pre>
<p>When <kbd><b>pthread_mutex_lock()</b></kbd> returns, the mutex is locked.
The calling thread is the owner. If the mutex is already locked and owned
by another thread, the calling thread blocks until the mutex becomes available.</p>
<p>
<a name="indexterm-134"></a>If the mutex type is <tt>PTHREAD_MUTEX_NORMAL</tt> , deadlock detection is not provided. Attempting to relock the
mutex causes deadlock. If a thread attempts to unlock a mutex not locked by
the thread or a mutex that is unlocked, undefined behavior results.</p>
<p>
<a name="indexterm-135"></a>If the mutex type is <tt>PTHREAD_MUTEX_ERRORCHECK</tt> , then error checking is provided. If a thread attempts to relock
a mutex that the thread has already locked, an error is returned. If a thread
attempts to unlock a mutex not locked by the thread or a mutex that is unlocked,
an error is returned.</p>
<p>
<a name="indexterm-136"></a>If the mutex type is <tt>PTHREAD_MUTEX_RECURSIVE</tt> , then the mutex maintains the concept of a lock count. When a
thread successfully acquires a mutex for the first time, the lock count is
set to 1. Every time a thread relocks this mutex, the lock count is incremented
by 1. Every time the thread unlocks the mutex, the lock count is decremented
by 1. When the lock count reaches 0, the mutex becomes available for other
threads to acquire. If a thread attempts to unlock a mutex not locked by the
thread or a mutex that is unlocked, an error is returned.</p>
<p>The mutex type <tt>PTHREAD_MUTEX_DEFAULT</tt> is the same
as <tt>PTHREAD_MUTEX_NORMAL</tt>.</p>
<a name="6mba5vq01"></a><h3 class="sol">
<tt>pthread_mutex_lock</tt> Return Values</h3>
<p>
<a name="indexterm-137"></a><kbd><b>pthread_mutex_lock()</b></kbd> returns
zero after completing successfully. Any other return value indicates that
an error occurred. When any of the following conditions occurs, the function
fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EAGAIN</samp></tt>
</p>

<b>Description: </b>
<p>The mutex could not be acquired because
the maximum number of recursive locks for mutex has been exceeded.</p>


</dl><dl>
<br>
<p>
<tt><samp>EDEADLK</samp></tt>
</p>

<b>Description: </b>
<p>The current thread already owns the mutex.</p>


</dl><p>If the mutex was initialized with the <tt>PTHREAD_MUTEX_ROBUST_NP</tt>robustness
attribute, <kbd><b>pthread_mutex_lock()</b></kbd> may return one of the following
values:</p>
<dl>
<br>
<p>
<tt><samp>EOWNERDEAD</samp></tt>
</p>

<b>Description: </b>
<p>The last owner of this mutex terminated
while holding the mutex. This mutex is now owned by the caller. The caller
must attempt to make the state protected by the mutex consistent.</p>

<p>If
the caller is able to make the state consistent, call <kbd><b>pthread_mutex_consistent_np()</b></kbd> for the mutex and unlock the mutex. Subsequent calls to <kbd><b>pthread_mutex_lock()</b></kbd> behave normally.</p>

<p>If the caller is unable to make the state consistent, do not call <kbd><b>pthread_mutex_init()</b></kbd> for the mutex. Unlock the mutex instead. Subsequent
calls to <kbd><b>pthread_mutex_lock()</b></kbd> fail to acquire the mutex
and return an <samp>ENOTRECOVERABLE</samp> error code.</p>

<p>If the owner that acquired the lock with <samp>EOWNERDEAD</samp> terminates
while holding the mutex, the next owner acquires the lock with <samp>EOWNERDEAD</samp>.</p>


</dl><dl>
<br>
<p>
<tt><samp>ENOTRECOVERABLE</samp></tt>
</p>

<b>Description: </b>
<p>The mutex you are trying to acquire was
protecting state left irrecoverable by the mutex's previous owner. The mutex
has not been acquired. This irrecoverable condition can occur when:</p>

<a name=""></a>
<ul>
<li>
<p>The lock was previously acquired with <samp>EOWNERDEAD</samp>
</p>


</li>
<li>
<p>The owner was unable to cleanup the state</p>


</li>
<li>
<p>The owner unlocked the mutex without making the mutex state
consistent</p>


</li>
</ul>


<br>
<p>
<tt><samp>ENOMEM</samp></tt>
</p>

<b>Description: </b>
<p>The limit on the number of simultaneously
held mutexes has been exceeded.</p>


</dl><a name="6mba5vq03"></a><h2 class="sol">Unlocking a Mutex</h2>
<p>
<a name="indexterm-138"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutex-unlock-3c/index.html">pthread_mutex_unlock(3C)</a> to unlock the mutex pointed to by <var>mutex</var>. </p>
<a name="6mba5vq05"></a><h3 class="sol">
<tt>pthread_mutex_unlock</tt> Syntax</h3>
<a name="sync-ix305"></a><a name=""></a><pre>int pthread_mutex_unlock(pthread_mutex_t *<var>mutex</var>); </pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;

pthread_mutex_t <var>mutex</var>;
int <var>ret</var>;

<var>ret</var> = pthread_mutex_unlock(&amp;<var>mutex</var>); /* release the mutex */</pre>
<p>
<kbd><b>pthread_mutex_unlock()</b></kbd> releases the mutex object
referenced by <var>mutex</var>. The manner in which a mutex
is released is dependent upon the mutex's type attribute. If threads are blocked
on the <var>mutex</var> object when <kbd><b>pthread_mutex_unlock()</b></kbd> is called and the mutex becomes available, the scheduling policy
determines which thread acquires the mutex. For  <tt>PTHREAD_MUTEX_RECURSIVE</tt> mutexes, the mutex becomes available when the count reaches zero
and the calling thread no longer has any locks on this mutex. </p>
<a name="6mba5vq07"></a><h3 class="sol">
<tt>pthread_mutex_unlock</tt> Return
Values</h3>
<p>
<a name="indexterm-139"></a><kbd><b>pthread_mutex_unlock()</b></kbd> returns
zero after completing successfully. Any other return value indicates that
an error occurred. When the following condition occurs, the function fails
and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EPERM</samp></tt>
</p>

<b>Description: </b>
<p>The current thread does not own the mutex.</p>


</dl><a name="6mba5vq09"></a><h2 class="sol">Locking a Mutex Without Blocking</h2>
<p>
<a name="indexterm-140"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutex-trylock-3c/index.html">pthread_mutex_trylock(3C)</a> to attempt
to lock the mutex pointed to by <var>mutex</var>, and return
immediately if the mutex is already locked.</p>
<a name="6mba5vq0b"></a><h3 class="sol">
<tt>pthread_mutex_trylock</tt> Syntax</h3>
<a name="sync-ix308"></a><a name=""></a><pre>int pthread_mutex_trylock(pthread_mutex_t *<var>mutex</var>); </pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;

pthread_mutex_t <var>mutex</var>;
int <var>ret</var>;

<var>ret</var> = pthread_mutex_trylock(&amp;<var>mutex</var>); /* try to lock the mutex */</pre>
<p>
<kbd><b>pthread_mutex_trylock()</b></kbd> is a nonblocking version
of  <kbd><b>pthread_mutex_lock()</b></kbd>. If the mutex object referenced
by <var>mutex</var> is currently locked by any thread, including
the current thread, the call returns immediately. Otherwise, the mutex is
locked and the calling thread is the owner.</p>
<a name="6mba5vq0d"></a><h3 class="sol">
<tt>pthread_mutex_trylock</tt> Return
Values</h3>
<p>
<a name="indexterm-141"></a><kbd><b>pthread_mutex_trylock()</b></kbd> returns
zero after completing successfully. Any other return value indicates that
an error occurred. When any of the following conditions occurs, the function
fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EBUSY</samp></tt>
</p>

<b>Description: </b>
<p>The mutex could not be acquired because
the mutex pointed to by <var>mutex</var> was already locked.</p>


</dl><dl>
<br>
<p>
<tt><samp>EAGAIN</samp></tt>
</p>

<b>Description: </b>
<p>The mutex could not be acquired because
the maximum number of recursive locks for <var>mutex</var> has
been exceeded.</p>


</dl><p>If the symbol <tt>_POSIX_THREAD_PRIO_INHERIT</tt> is defined,
the mutex is initialized with the protocol attribute value <tt>PTHREAD_PRIO_INHERIT</tt> . Additionally, if the <var>robustness</var> argument
of  <kbd><b>pthread_mutexattr_setrobust_np()</b></kbd> is <tt>PTHREAD_MUTEX_ROBUST_NP</tt>, the function fails and returns one of the following values:</p>
<dl>
<br>
<p>
<tt><samp>EOWNERDEAD</samp></tt>
</p>

<b>Description: </b>
<p>See the discussion in <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-238/index.html"><tt>pthread_mutex_lock</tt> Return Values</a>. </p>


</dl><dl>
<br>
<p>
<tt><samp>ENOTRECOVERABLE</samp></tt>
</p>

<b>Description: </b>
<p>See the discussion in <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-238/index.html"><tt>pthread_mutex_lock</tt> Return Values</a>. </p>


<br>
<p>
<tt><samp>ENOMEM</samp></tt>
</p>

<b>Description: </b>
<p>The limit on the number of simultaneously
held mutexes has been exceeded.</p>


</dl><a name="6mba5vq0f"></a><h2 class="sol">Locking a Mutex Before a Specified Absolute Time</h2>
<p>Use the <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutex-timedlock-3c/index.html">pthread_mutex_timedlock(3C)</a> function
to attempt until a specified time to lock a mutex object.</p>
<p>This function works as the <kbd><b>pthread_mutex_lock()</b></kbd> function
does, except that it does not block indefinitely. If the mutex is already
locked, the calling thread is blocked until the mutex becomes available, but
only until the timeout is reached. If the timeout occurs before the mutex
becomes available, the function returns.</p>
<a name="6mba5vq0h"></a><h3 class="sol">
<kbd><b>pthread_mutex_timedlock()</b></kbd> Syntax</h3>
<a name="indexterm-142"></a><a name=""></a><pre>int  pthread_mutex_timedlock(pthread_mutex_t *restrict <var>mutex</var>, 
          const struct timespec *restrict <var>abs_timeout</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

pthread_mutex_t <var>mutex</var>;
timestruct_t <var>abs_timeout</var>;
int <var>ret</var>;

<var>ret</var> = pthread_mutex_timedlock(&amp;<var>mutex</var>,  &amp;<var>abs_timeout</var>); </pre>
<a name="6mba5vq0j"></a><h3 class="sol">
<kbd><b>pthread_mutex_timedlock()</b></kbd> Return
Values</h3>
<a name="indexterm-143"></a><p>The <kbd><b>pthread_mutex_timedlock()</b></kbd> function return 0 if
it locks the mutex successfully. Otherwise, an error number is returned to
indicate the error.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The mutex was created with the protocol
attribute having the value <tt>PTHREAD_PRIO_PROTECT</tt> and 
the calling thread's priority is higher than the mutex's current priority
ceiling. </p>

<b>Description: </b>
<p>The value specified by <var>mutex</var> does
not refer to an initialized mutex object.</p>

<b>Description: </b>
<p>The process or thread would have blocked,
and the <var>abs_timeout</var> parameter specified a nanoseconds
field value less than 0 or greater than or equal to 1000 million.</p>


</dl><dl>
<br>
<p>
<tt><samp>ETIMEDOUT</samp></tt>
</p>

<b>Description: </b>
<p>The mutex could not be locked before the
specified timeout expired.</p>


</dl><p>See the discussion in <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-238/index.html"><tt>pthread_mutex_lock</tt> Return Values</a>.</p>
<a name="6mba5vq0l"></a><h2 class="sol">Locking a Mutex Within a Specified Time Interval</h2>
<p>Use the <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutex-reltimedlock-np-3c/index.html">pthread_mutex_reltimedlock_np(3C)</a> function
to attempt until a specified amount of time elapses to lock a mutex object. </p>
<p>The timeout expires when the time interval specified by <var>rel_timeout</var> passes, as measured by the <tt>CLOCK_REALTIME</tt> clock,
or if the time interval specified by <var>rel_timeout</var> is
negative at the time of the call.</p>
<a name="6mba5vq0n"></a><h3 class="sol">
<kbd><b>pthread_mutex_reltimedlock_np()</b></kbd> Syntax</h3>
<a name="indexterm-144"></a><a name=""></a><pre>int  pthread_mutex_reltimedlock_np(pthread_mutex_t *restrict <var>mutex</var>, 
          const struct timespec *restrict <var>rel_timeout</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

pthread_mutex_t <var>mutex</var>;
timestruct_t <var>rel_timeout</var>;
int <var>ret</var>;

<var>ret</var> = pthread_mutex_reltimedlock_np(&amp;<var>mutex</var>,  &amp;<var>rel_timeout</var>); </pre>
<a name="6mba5vq0p"></a><h3 class="sol">
<kbd><b>pthread_mutex_reltimedlock_np()</b></kbd> Return
Values</h3>
<a name="indexterm-145"></a><p>The <kbd><b>pthread_mutex_reltimedlock_np()</b></kbd> function returns
0 if it locks the mutex successfully. Otherwise, an error number is returned
to indicate the error.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The mutex was created with the protocol
attribute having the value <tt>PTHREAD_PRIO_PROTECT</tt> and 
the calling thread's priority is higher than the mutex's current priority
ceiling. </p>

<b>Description: </b>
<p>The value specified by <var>mutex</var> does
not refer to an initialized mutex object.</p>

<b>Description: </b>
<p>The process or thread would have blocked,
and the <var>abs_timeout</var> parameter specified a nanoseconds
field value less than 0 or greater than or equal to 1000 million.</p>


</dl><dl>
<br>
<p>
<tt><samp>ETIMEDOUT</samp></tt>
</p>

<b>Description: </b>
<p>The mutex could not be locked before the
specified timeout expired.</p>


</dl><p>See the discussion in <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-238/index.html"><tt>pthread_mutex_lock</tt> Return Values</a>. </p>
<a name="6mba5vq0r"></a><h2 class="sol">Destroying a Mutex</h2>
<p>
<a name="indexterm-146"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-mutex-destroy-3c/index.html">pthread_mutex_destroy(3C)</a> to destroy
any state that is associated with the mutex pointed to by <var>mp</var> . </p>
<a name="6mba5vq0t"></a><h3 class="sol">
<tt>pthread_mutex_destroy</tt> Syntax</h3>
<a name="sync-ix311"></a><a name=""></a><pre>int pthread_mutex_destroy(pthread_mutex_t *<var>mp</var>); </pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;

pthread_mutex_t <var>mp</var>;
int <var>ret</var>;

<var>ret</var> = pthread_mutex_destroy(&amp;<var>mp</var>); /* mutex is destroyed */</pre>
<p>Note that the space for storing the mutex is not freed.</p>
<a name="6mba5vq0v"></a><h3 class="sol">
<tt>pthread_mutex_destroy</tt> Return
Values</h3>
<p>
<a name="indexterm-147"></a><kbd><b>pthread_mutex_destroy()</b></kbd> returns
zero after completing successfully. Any other return value indicates that
an error occurred. When any of the following conditions occur, the function
fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>mp</var> does
not refer to an initialized mutex object.</p>


</dl><a name="6mba5vq11"></a><h2 class="sol">Code Examples of Mutex Locking</h2>
<p>
<a name="sync-ix313"></a><a name="sync-ix314"></a><a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq11/index.html#sync-83415">Example 4–1</a> shows
some code fragments with mutex locking.</p>
<a name="sync-83415"></a><hr><h5 class="sol">Example 4–1  Mutex Lock Example</h5><br><a name=""></a><pre>#include &lt;pthread.h&gt;

pthread_mutex_t count_mutex;
long long count;

void
increment_count()
{
    pthread_mutex_lock(&amp;count_mutex);
    count = count + 1;
    pthread_mutex_unlock(&amp;count_mutex);
}

long long
get_count()
{
    long long c;
    
    pthread_mutex_lock(&amp;count_mutex);
    c = count;
    pthread_mutex_unlock(&amp;count_mutex);
    return (c);
}</pre>
<hr>
<p>The two functions in <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq11/index.html#sync-83415">Example 4–1</a> use
the mutex lock for different purposes. The <kbd><b>increment_count()</b></kbd> 
function uses the mutex lock to ensure an atomic update of the shared variable.
The <kbd><b>get_count()</b></kbd> function uses the mutex lock to guarantee
that the 64-bit quantity <var>count</var> is read atomically.
On a 32-bit architecture, a <code>long</code> <code>long</code> is really
two 32-bit quantities.</p>
<p>When you read an integer value, the operation is atomic because an integer
is the common word size on most machines.</p>
<a name="6mba5vq13"></a><h3 class="sol">Examples of Using Lock Hierarchies</h3>
<p>
<a name="indexterm-148"></a>Occasionally, you might want to access two resources at once.
Perhaps you are using one of the resources, and then discover that the other
resource is needed as well. A problem exists if two threads attempt to claim
both resources but lock the associated mutexes in different orders. For example,
if the two threads lock mutexes 1 and 2 respectively, a deadlock occurs when
each attempts to lock the other mutex. <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq13/index.html#sync-ex-2">Example 4–2</a> shows possible deadlock scenarios.</p>
<a name="sync-ex-2"></a><hr><h5 class="sol">Example 4–2  Deadlock</h5><br><a name=""></a><a name=""></a><table width="100%" cellpadding="10" cellspacing="0" border="1">
<thead>
<tr>
<th scope="col" align="left" valign="top">
<p>Thread 1&nbsp;</p>

</th><th scope="col" align="left" valign="top">
<p>Thread 2&nbsp;</p>

</th>
</tr>

</thead>
<tbody>
<tr>
<td align="left" valign="top"><a name=""></a>
<pre>pthread_mutex_lock(&amp;m1);

/* use resource 1 */


pthread_mutex_lock(&amp;m2);


/* use resources 1 and 2 */


pthread_mutex_unlock(&amp;m2);


pthread_mutex_unlock(&amp;m1);</pre>


</td><td align="left" valign="top"><a name=""></a>
<pre>pthread_mutex_lock(&amp;m2);

/* use resource 2 */


pthread_mutex_lock(&amp;m1);


/* use resources 1 and 2 */


pthread_mutex_unlock(&amp;m1);


pthread_mutex_unlock(&amp;m2);</pre>


</td>
</tr>

</tbody>
</table>
<p> 
</p><p> 
</p><hr>
<p>The best way to avoid this problem is to make sure that when threads
lock multiple mutexes, the threads do so in the same order. When locks are
always taken in a prescribed order, deadlock should not occur. This technique,
known as lock hierarchies, orders the mutexes by logically assigning numbers
to the mutexes.</p>
<p>Also, honor the restriction that you cannot take a mutex that is assigned
 <b>n</b> when you are holding any mutex assigned a number that
is greater than  <b>n</b>.</p>
<p>
<a name="sync-ix317"></a>However, this technique cannot always be used. Sometimes,
you must take the mutexes in an order other than prescribed. To prevent deadlock
in such a situation, use <kbd><b>pthread_mutex_trylock()</b></kbd>. One thread
must release its mutexes when the thread discovers that deadlock would otherwise
be inevitable.</p>
<a name="sync-ex-13"></a><hr><h5 class="sol">Example 4–3  Conditional Locking</h5><br><a name=""></a><a name=""></a><table width="100%" cellpadding="10" cellspacing="0" border="1">
<thead>
<tr>
<th scope="col" align="left" valign="top">
<p>thread1&nbsp;</p>

</th><th scope="col" align="left" valign="top">
<p>thread2&nbsp;</p>

</th>
</tr>

</thead>
<tbody>
<tr>
<td align="left" valign="top">
<p>
<tt>pthread_mutex_lock(&amp;m1); pthread_mutex_lock(&amp;m2);</tt>
</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>/* no processing */&nbsp;</p>
<p>&nbsp;</p>
<p>
<tt>pthread_mutex_unlock(&amp;m2);</tt>
</p>
<p>
<tt>pthread_mutex_unlock(&amp;m1</tt>);</p>

</td><td align="left" valign="top">
<p>
<tt>for (; ;)</tt>
</p>
<p>
<tt>{ pthread_mutex_lock(&amp;m2);</tt>
</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>
<tt>if(pthread_mutex_trylock(&amp;m1)==0)</tt>
</p>
<p>/* got it */&nbsp;</p>
<p>
<tt>break;</tt>
</p>
<p>/* didn't get it */&nbsp;</p>
<p>
<tt>pthread_mutex_unlock(&amp;m2);</tt>
</p>
<p>
<tt>}</tt>
</p>
<p>/* get locks; no processing */&nbsp;</p>
<p>
<tt>pthread_mutex_unlock(&amp;m1);</tt>
</p>
<p>
<tt>pthread_mutex_unlock(&amp;m2);</tt>
</p>

</td>
</tr>

</tbody>
</table>
<p> 
</p><p> 
</p><hr>
<p>In <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq13/index.html#sync-ex-13">Example 4–3</a>, thread1
locks mutexes in the prescribed order, but thread2 takes the mutexes out of
order. To make certain that no deadlock occurs, thread2 has to take mutex1
very carefully. If thread2 blocks while waiting for the mutex to be released,
thread2 is likely to have just entered into a deadlock with thread1.</p>
<p>
<a name="sync-ix320"></a>To ensure that thread2 does not enter into a deadlock, thread2
calls  <kbd><b>pthread_mutex_trylock()</b></kbd>, which takes the mutex if
available. If the mutex is not available, thread2 returns immediately, reporting
failure. At this point, thread2 must release mutex2. Thread1 can now lock
mutex2, and then release both mutex1 and mutex2.</p>
<a name="6mba5vq14"></a><h3 class="sol">Examples of Using Nested Locking With a Singly-Linked
List</h3>
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq14/index.html#sync-78558">Example 4–4</a> and <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq14/index.html#sync-94944">Example 4–5</a> show how to take three
locks at once. Deadlock is prevented by taking the locks in a prescribed order.</p>
<a name="sync-78558"></a><hr><h5 class="sol">Example 4–4  Singly-Linked List Structure</h5><br><a name=""></a><pre>typedef struct node1 {
    int value;
    struct node1 *link;
    pthread_mutex_t lock;
} node1_t;

node1_t ListHead;</pre>
<hr>
<p>
<a name="indexterm-149"></a>This example uses a singly linked list structure with each node
that contains a mutex. To remove a node from the list, first search the list
starting at  <tt>ListHead</tt> until the desired node is found. <tt>ListHead</tt> is never removed.</p>
<p>To protect this search from the effects of concurrent deletions, lock
each node before any of its contents are accessed. Because all searches start
at  <tt>ListHead</tt>, a deadlock cannot occur because the locks
are always taken in list order.</p>
<p>
<a name="sync-ix321"></a><a name="indexterm-150"></a><a name="sync-ix322"></a>When the desired node is found,
lock both the node and its predecessor since the change involves both nodes.
Because the predecessor's lock is always taken first, you are again protected
from deadlock. <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq14/index.html#sync-94944">Example 4–5</a> shows
the C code to remove an item from a singly-linked list.</p>
<a name="sync-94944"></a><hr><h5 class="sol">Example 4–5  Singly-Linked List With Nested Locking</h5><br><a name=""></a><pre>node1_t *delete(int value)
{
    node1_t *prev, *current;

    prev = &amp;ListHead;
    pthread_mutex_lock(&amp;prev-&gt;lock);
    while ((current = prev-&gt;link) != NULL) {
        pthread_mutex_lock(&amp;current-&gt;lock);
        if (current-&gt;value == value) {
            prev-&gt;link = current-&gt;link;
            pthread_mutex_unlock(&amp;current-&gt;lock);
            pthread_mutex_unlock(&amp;prev-&gt;lock);
            current-&gt;link = NULL;
            return(current);
        }
        pthread_mutex_unlock(&amp;prev-&gt;lock);
        prev = current;
    }
    pthread_mutex_unlock(&amp;prev-&gt;lock);
    return(NULL);
}</pre>
<hr>
<a name="6mba5vq15"></a><h3 class="sol">Example of Nested Locking With a Circularly-Linked
List</h3>
<p>
<a name="indexterm-151"></a><a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq15/index.html#sync-50939">Example 4–6</a> modifies
the previous list structure by converting the list structure into a circular
list. Because a distinguished head node no longer exists, a thread can be
associated with a particular node and can perform operations on that node
and its neighbor Lock hierarchies do not work easily here because the obvious
hierarchy, following the links, is circular.</p>
<a name="sync-50939"></a><hr><h5 class="sol">Example 4–6  Circular-Linked List Structure</h5><br><a name=""></a><pre>typedef struct node2 {
    int value;
    struct node2 *link;
    pthread_mutex_t lock;
} node2_t;</pre>
<hr>
<p>
<a name="sync-ix323"></a><a name="sync-ix324"></a><a name="sync-ix325"></a><a name="sync-ix327"></a><a name="sync-ix326"></a>Here
is the C code that acquires the locks on two nodes and performs an operation
that involves both locks.</p>
<a name="sync-ex-15"></a><hr><h5 class="sol">Example 4–7  Circular Linked List With Nested Locking</h5><br><a name=""></a><pre>void Hit Neighbor(node2_t *me) {
    while (1) {
        pthread_mutex_lock(&amp;me-&gt;lock);
        if (pthread_mutex_trylock(&amp;me-&gt;link-&gt;lock)!= 0) {
            /* failed to get lock */             
            pthread_mutex_unlock(&amp;me-&gt;lock);              
            continue;         
        }         
        break;     
    }     
    me-&gt;link-&gt;value += me-&gt;value;     
    me-&gt;value /=2;     
    pthread_mutex_unlock(&amp;me-&gt;link-&gt;lock);     
    pthread_mutex_unlock(&amp;me-&gt;lock);
}</pre>
<hr>
<a name="6mba5vq16"></a><h1 class="sol">Using Spin Locks</h1>
<a name="indexterm-152"></a><p>Spin locks are a low-level synchronization mechanism suitable primarily
for use on shared memory multiprocessors. When the calling thread requests
a spin lock that is already held by another thread, the second thread spins
in a loop to test if the lock has become available. When the lock is obtained,
it should be held only for a short time, as the spinning wastes processor
cycles. Callers should unlock spin locks before calling sleep operations to
enable other threads to obtain the lock.</p>
<p>Spin locks can be implemented using mutexes and conditional variables,
but the <tt>pthread_spin_*</tt> functions are a standardized way
to practice spin locking. The <tt>pthread_spin_*</tt> functions
require much lower overhead for locks of short duration.</p>
<p>When performing any lock, a trade-off is made between the processor
resources consumed while setting up to block the thread and the processor
resources consumed by the thread while it is blocked. Spin locks require few
resources to set up the blocking of a thread and then do a simple loop, repeating
the atomic locking operation until the lock is available. The thread continues
to consume processor resources while it is waiting.</p>
<p>Compared to spin locks, mutexes consume a larger amount of processor
resources to block the thread. When a mutex lock is not available, the thread
changes its scheduling state and adds itself to the queue of waiting threads.
When the lock becomes available, these steps must be reversed before the thread
obtains the lock. While the thread is blocked, it consumes no processor resources.</p>
<p>Therefore, spin locks and mutexes can be useful for different purposes.
Spin locks might have lower overall overhead for very short-term blocking,
and mutexes might have lower overall overhead when a thread will be blocked
for longer periods of time.</p>
<a name="6mba5vq18"></a><h2 class="sol">Initializing a Spin Lock</h2>
<p>Use the <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-spin-init-3c/index.html">pthread_spin_init(3C)</a> function to allocate resources required to use a spin
lock, and initialize the lock to an unlocked state.</p>
<a name="6mba5vq1a"></a><h3 class="sol">
<kbd><b>pthread_spin_init()</b></kbd> Syntax</h3>
<a name="indexterm-153"></a><a name=""></a><pre>int  pthread_spin_init(pthread_spinlock_t *<var>lock</var>, int <var>pshared</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;

pthread_spinlock_t <var>lock</var>;
int <var>pshared</var>;
int <var>ret</var>;

/* initialize a spin lock */
<var>ret</var> = pthread_spin_init(&amp;<var>lock</var>, <var>pshared</var>); </pre>
<p>The <var>pshared</var> attribute has one of the following
values:</p>
<dl>
<br>
<p>
<tt><tt>PTHREAD_PROCESS_SHARED</tt></tt>
</p>

<b>Description: </b>
<p>Permits a spin lock to be operated on
by any thread that has access to the memory where the spin lock is allocated.
Operation on the lock is permitted even if the lock is allocated in memory
that is shared by multiple processes.</p>


</dl><dl>
<br>
<p>
<tt><tt>PTHREAD_PROCESS_PRIVATE</tt></tt>
</p>

<b>Description: </b>
<p>Permits a spin lock to be operated upon
only by threads created within the same process as the thread that initialized
the spin lock. If threads of differing processes attempt to operate on such
a spin lock, the behavior is undefined. The default value of the process-shared
attribute is  <tt>PTHREAD_PROCESS_PRIVATE</tt>.</p>


</dl><a name="6mba5vq1c"></a><h3 class="sol">
<kbd><b>pthread_spin_init()</b></kbd> Return Values</h3>
<p>Upon successful completion, the <kbd><b>pthread_spin_init()</b></kbd> function
returns 0. Otherwise, one of the following error codes is returned.</p>
<dl>
<br>
<p>
<tt>EAGAIN</tt>
</p>

<b>Description: </b>
<p>The system lacks the necessary resources
to initialize another spin lock.</p>


</dl><dl>
<br>
<p>
<tt>EBUSY</tt>
</p>

<b>Description: </b>
<p>The system has detected an attempt  to
 initialize or destroy a spin lock while the lock is in use (for example,
while being used in a <kbd><b>pthread_spin_lock()</b></kbd> call) by another
thread.</p>


</dl><dl>
<br>
<p>
<tt>EINVAL</tt>
</p>

<b>Description: </b>
<p>The value specified by <var>lock</var> is
invalid.</p>


</dl><a name="6mba5vq1e"></a><h2 class="sol">Acquiring a Spin Lock</h2>
<p>Use the <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-spin-lock-3c/index.html">pthread_spin_lock(3C)</a> to lock a spin lock. The calling thread acquires the
lock if it is not held by another thread. Otherwise, the thread does not return
from the <kbd><b>pthread_spin_lock()</b></kbd> call until the lock becomes
available. The results are undefined if the calling thread holds the lock
at the time the call is made.</p>
<a name="6mba5vq1g"></a><h3 class="sol">
<kbd><b>pthread_spin_lock()</b></kbd> Syntax</h3>
<a name="indexterm-154"></a><a name=""></a><pre>int  pthread_spin_lock(pthread_spinlock_t *<var>lock</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;

pthread_spinlock_t <var>lock</var>;
int <var>ret</var>;

<var>ret</var> = pthread_ spin_lock(&amp;<var>lock</var>); /* lock the spinlock */</pre>
<a name="6mba5vq1i"></a><h3 class="sol">
<kbd><b>pthread_spin_lock()</b></kbd> Return Values</h3>
<a name="indexterm-155"></a><p>Upon successful completion, the <kbd><b>pthread_spin_lock()</b></kbd> function
returns 0. Otherwise, one of the following error codes is returned.</p>
<dl>
<br>
<p>
<tt><samp>EDEADLK</samp></tt>
</p>

<b>Description: </b>
<p>The current thread already owns the spin
lock.</p>


</dl><dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>lock</var> does
not refer to an initialized spin lock object.</p>


</dl><a name="6mba5vq1k"></a><h2 class="sol">Acquiring a Non-Blocking Spin Lock</h2>
<p>Use the <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-spin-trylock-3c/index.html">pthread_spin_trylock(3C)</a> function to lock a spin lock and fail immediately
if the lock is held by another thread.</p>
<a name="6mba5vq1m"></a><h3 class="sol">
<kbd><b>pthread_spin_trylock()</b></kbd> Syntax</h3>
<a name="indexterm-156"></a><a name=""></a><pre>int  pthread_spin_trylock(pthread_spinlock_t *<var>lock</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;

pthread_spinlock_t <var>lock</var>;
int <var>ret</var>;

<var>ret</var> = pthread_spin_trylock(&amp;<var>lock</var>); /* try to lock the spin lock */</pre>
<a name="6mba5vq1o"></a><h3 class="sol">
<kbd><b>pthread_spin_trylock()</b></kbd> Return
Values</h3>
<a name="indexterm-157"></a><p>Upon successful completion, the <kbd><b>pthread_spin_trylock()</b></kbd> function
returns 0. Otherwise, one of the following error codes is returned.</p>
<dl>
<br>
<p>
<tt><samp>EBUSY</samp></tt>
</p>

<b>Description: </b>
<p>A thread currently owns the spin lock.</p>


</dl><dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>lock</var> does
not refer to an initialized spin lock object.</p>


</dl><a name="6mba5vq1q"></a><h2 class="sol">Unlocking a Spin Lock</h2>
<p>Use the <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-spin-unlock-3c/index.html">pthread_spin_unlock(3C)</a> function to release a locked spin lock.</p>
<a name="6mba5vq1s"></a><h3 class="sol">
<kbd><b>pthread_spin_unlock()</b></kbd> Syntax</h3>
<a name="indexterm-158"></a><a name=""></a><pre>int  pthread_spin_unlock(pthread_spinlock_t *<var>lock</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;

pthread_spinlock_t <var>lock</var>;
int <var>ret</var>;

<var>ret</var> = pthread_spin_unlock(&amp;<var>lock</var>); /* spinlock is unlocked */</pre>
<a name="6mba5vq1u"></a><h3 class="sol">
<kbd><b>pthread_spin_unlock()</b></kbd> Return Values</h3>
<a name="indexterm-159"></a><p>Upon successful completion, the <kbd><b>pthread_spin_unlock()</b></kbd> function
returns 0. Otherwise, one of the following error codes is returned.</p>
<dl>
<br>
<p>
<tt><samp>EPERM</samp></tt>
</p>

<b>Description: </b>
<p>The calling thread does not hold the lock.</p>


</dl><dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>lock</var> does
not refer to an initialized spin lock object.</p>


</dl><a name="6mba5vq20"></a><h2 class="sol">Destroying a Spin Lock</h2>
<p>Use the <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-spin-destroy-3c/index.html">pthread_spin_destroy(3C)</a> function to destroy a spin lock and release any resources
used by the lock. </p>
<a name="6mba5vq22"></a><h3 class="sol">
<kbd><b>pthread_spin_destroy()</b></kbd> Syntax</h3>
<a name="indexterm-160"></a><a name=""></a><pre>int  pthread_spin_destroy(pthread_spinlock_t *<var>lock</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;

pthread_spinlock_t <var>lock</var>;
int <var>ret</var>;

<var>ret</var> = pthread_spin_destroy(&amp;<var>lock</var>); /* spinlock is destroyed */</pre>
<p>The effect of subsequent use of the lock is undefined until the lock
is reinitialized  by another call to <kbd><b>pthread_spin_init()</b></kbd>.
The results are undefined if <kbd><b>pthread_spin_destroy()</b></kbd> is
called when  a thread holds the lock, or if this function is called with an
uninitialized thread spin lock.</p>
<a name="6mba5vq24"></a><h3 class="sol">
<kbd><b>pthread_spin_destroy()</b></kbd> Return
Values</h3>
<a name="indexterm-161"></a><dl>
<br>
<p>
<tt>EBUSY</tt>
</p>

<b>Description: </b>
<p>The system has detected an attempt  to
 initialize or destroy a spin lock while the lock is in use (for example,
while being used in a <kbd><b>pthread_spin_lock()</b></kbd> call) by another
thread.</p>


</dl><dl>
<br>
<p>
<tt>EINVAL</tt>
</p>

<b>Description: </b>
<p>The value specified by <var>lock</var> is
invalid.</p>


</dl><a name="6mba5vq26"></a><h1 class="sol">Condition Variable Attributes</h1>
<a name="sync-ix328"></a><a name="sync-ix329"></a><a name="sync-ix330"></a><p>Use condition variables to atomically block threads until a particular
condition is true. Always use condition variables together with a mutex lock.</p>
<p>With a condition variable, a thread can atomically block until a condition
is satisfied. The condition is tested under the protection of a mutual exclusion
lock (mutex).</p>
<p>When the condition is false, a thread usually blocks on a condition
variable and atomically releases the mutex waiting for the condition to change.
When another thread changes the condition, that thread can signal the associated
condition variable to cause one or more waiting threads to perform the following
actions:</p>
<a name=""></a><ul>
<li>
<p>Wake up</p>


</li>
<li>
<p>Acquire the mutex again</p>


</li>
<li>
<p>Re-evaluate the condition</p>


</li>
</ul>
<p>Condition variables can be used to synchronize threads among processes
in the following situations:</p>
<a name=""></a><ul>
<li>
<p>The threads are allocated in memory that can be written to</p>


</li>
<li>
<p>The memory is shared by the cooperating processes</p>


</li>
</ul>
<p>The scheduling policy determines how blocking threads are awakened.
The default scheduling policy, <tt>SCHED_OTHER</tt>, does not specify
the order in which threads are awakened. Under the <tt>SCHED_FIFO</tt> and <tt>SCHED_RR</tt> real-time scheduling policies, threads are awakened in
priority order.</p>
<p>The attributes for condition variables must be set and initialized before
the condition variables can be used. The functions that manipulate condition
variable attributes are listed in <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq26/index.html#sync-81445">Table 4–4</a>.</p>
<a name="sync-81445"></a>Table 4–4  Condition Variable Attributes<table width="100%" cellpadding="10" cellspacing="0" border="2">
<caption>
<b></b>
</caption>
<thead>
<tr>
<th scope="col" align="left" valign="top">
<p>Operation&nbsp;</p>

</th><th scope="col" align="left" valign="top">
<p>Function Description&nbsp;</p>

</th>
</tr>

</thead>
<tbody>
<tr>
<td align="left" valign="top">
<p>Initialize a condition variable attribute&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-72041/index.html"><tt>pthread_condattr_init</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Remove a condition variable attribute&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-64435/index.html"><tt>pthread_condattr_destroy</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Set the scope of a condition variable &nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-61843/index.html"><tt>pthread_condattr_setpshared</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Get the scope of a condition variable&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-85799/index.html"><tt>pthread_condattr_getpshared</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Get the clock selection condition variable attribute&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/gfvmc/index.html"><tt>pthread_condattr_getclock</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Set the clock selection condition variable attribute&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/gfvnn/index.html"><tt>pthread_condattr_setclock</tt> Syntax</a>
</p>

</td>
</tr>

</tbody>
</table>
<p> 
</p><a name="6mba5vq28"></a><h2 class="sol">Initializing a Condition Variable Attribute</h2>
<p>
<a name="indexterm-162"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-condattr-init-3c/index.html">pthread_condattr_init(3C)</a> to initialize
attributes that are associated with this object to their default values. Storage
for each attribute object is allocated by the threads system during execution.</p>
<a name="6mba5vq2a"></a><h3 class="sol">
<tt>pthread_condattr_init</tt> Syntax</h3>
<a name="sync-ix335"></a><a name=""></a><pre>int pthread_condattr_init(pthread_condattr_t *<var>cattr</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;
pthread_condattr_t <var>cattr</var>;
int <var>ret</var>;

/* initialize an attribute to default value */
<var>ret</var> = pthread_condattr_init(&amp;<var>cattr</var>); </pre>
<p>The default value of the <var>pshared</var> attribute
when this function is called is <tt>PTHREAD_PROCESS_PRIVATE</tt>.
This value of  <var>pshared</var> means that the initialized
condition variable can be used within a process.</p>
<p>
<var>cattr</var> is an opaque data type that contains
a system-allocated attribute object. The possible values of <var>cattr</var>'s
scope are <tt>PTHREAD_PROCESS_PRIVATE</tt> and <tt>PTHREAD_PROCESS_SHARED</tt> . <tt>PTHREAD_PROCESS_PRIVATE</tt> is the default value.</p>
<p>Before a condition variable attribute can be reused, the attribute must
first be reinitialized by <tt>pthread_condattr_destroy(3C)</tt>.
The  <kbd><b>pthread_condattr_init()</b></kbd> call returns a pointer to
an opaque object. If the object is not destroyed, a memory leak results.</p>
<a name="6mba5vq2c"></a><h3 class="sol">
<tt>pthread_condattr_init</tt> Return
Values</h3>
<p>
<a name="indexterm-163"></a><kbd><b>pthread_condattr_init()</b></kbd> returns
zero after completing successfully. Any other return value indicates that
an error occurred. When either of the following conditions occurs, the function
fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>ENOMEM</samp></tt>
</p>

<b>Description: </b>
<p>Insufficient memory allocated to initialize
the thread attributes object.</p>


<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>cattr</var> is
invalid.</p>


</dl><a name="6mba5vq2e"></a><h2 class="sol">Removing a Condition Variable Attribute</h2>
<p>
<a name="indexterm-164"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-condattr-destroy-3c/index.html">pthread_condattr_destroy(3C)</a> to remove
storage and render the attribute object invalid.</p>
<a name="6mba5vq2g"></a><h3 class="sol">
<tt>pthread_condattr_destroy</tt> Syntax</h3>
<a name="sync-ix341"></a><a name=""></a><pre>int pthread_condattr_destroy(pthread_condattr_t *<var>cattr</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;
pthread_condattr_t <var>cattr</var>;
int <var>ret</var>;

/* destroy an attribute */
<var>ret</var>
 = pthread_condattr_destroy(&amp;<var>cattr</var>); </pre>
<a name="6mba5vq2i"></a><h3 class="sol">
<tt>pthread_condattr_destroy</tt> Return
Values</h3>
<p>
<a name="indexterm-165"></a><kbd><b>pthread_condattr_destroy()</b></kbd> returns zero after completing successfully. Any other return value
indicates that an error occurred. If the following condition occurs, the function
fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>cattr</var> is
invalid.</p>


</dl><a name="6mba5vq2k"></a><h2 class="sol">Setting the Scope of a Condition Variable</h2>
<p>
<a name="indexterm-166"></a><a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-condattr-setpshared-3c/index.html">pthread_condattr_setpshared(3C)</a> sets the
scope of a condition variable to either process private (intraprocess) or
system wide (interprocess).</p>
<a name="6mba5vq2m"></a><h3 class="sol">
<tt>pthread_condattr_setpshared</tt> Syntax</h3>
<a name="sync-ix343"></a><a name=""></a><pre>int pthread_condattr_setpshared(pthread_condattr_t *<var>cattr</var>, int <var>pshared</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt; 
pthread_condattr_t <var>cattr</var>; 
int <var>ret</var>; 

/* all processes */ 
<var>ret</var> = pthread_condattr_setpshared(&amp;<var>cattr</var>, PTHREAD_PROCESS_SHARED); 

/* within a process */ 
<var>ret</var> = pthread_condattr_setpshared(&amp;<var>cattr</var>, PTHREAD_PROCESS_PRIVATE);</pre>
<p>A condition variable created with the <var>pshared</var> attribute
set in shared memory to <tt>PTHREAD_PROCESS_SHARED</tt>, can be
shared among threads from more than one process. </p>
<p>If the mutex <var>pshared</var> attribute is set to
 <tt>PTHREAD_PROCESS_PRIVATE</tt>, only those threads created by
the same process can operate on the mutex. <tt>PTHREAD_PROCESS_PRIVATE</tt> is
the default value. <tt>PTHREAD_PROCESS_PRIVATE</tt> behaves like
a local condition variable. The behavior of <tt>PTHREAD_PROCESS_SHARED</tt> is
equivalent to a global condition variable.</p>
<a name="6mba5vq2o"></a><h3 class="sol">
<tt>pthread_condattr_setpshared</tt> Return
Values</h3>
<p>
<a name="indexterm-167"></a><kbd><b>pthread_condattr_setpshared()</b></kbd>  returns zero after completing successfully. Any other return
value indicates that an error occurred. If the following condition occurs,
the function fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value of <var>cattr</var> is
invalid, or the <var>pshared</var> value is invalid.</p>


</dl><a name="6mba5vq2q"></a><h2 class="sol">Getting the Scope of a Condition Variable</h2>
<p>
<a name="indexterm-168"></a><a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-condattr-getpshared-3c/index.html">pthread_condattr_getpshared(3C)</a> gets the
current value of <var>pshared</var> for the attribute object <var>cattr</var>.</p>
<a name="6mba5vq2s"></a><h3 class="sol">
<tt>pthread_condattr_getpshared</tt> Syntax</h3>
<a name="sync-ix347"></a><a name=""></a><pre>int pthread_condattr_getpshared(const pthread_condattr_t *restrict <var>cattr</var>,
          int *restrict <var>pshared</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt; 

pthread_condattr_t <var>cattr</var>; 
int <var>pshared</var>; 
int <var>ret</var>; 

/* get pshared value of condition variable */ 
<var>ret</var> = pthread_condattr_getpshared(&amp;<var>cattr</var>, &amp;<var>pshared</var>); </pre>
<p>The value of the attribute object is either <tt>PTHREAD_PROCESS_SHARED</tt>  or <tt>PTHREAD_PROCESS_PRIVATE</tt>.</p>
<a name="6mba5vq2u"></a><h3 class="sol">
<tt>pthread_condattr_getpshared</tt> Return
Values</h3>
<p>
<a name="indexterm-169"></a><kbd><b>pthread_condattr_getpshared()</b></kbd>  returns zero after completing successfully. Any other return
value indicates that an error occurred. When the following condition occurs,
the function fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value of <var>cattr</var> is
invalid.</p>


</dl><a name="6mba5vq30"></a><h2 class="sol">Setting the Clock Selection Condition Variable</h2>
<p>
<a name="indexterm-170"></a>Use the <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-condattr-setclock-3c/index.html">pthread_condattr_setclock(3C)</a> function
to set the clock attribute in an initialized attributes object referenced
by <var>attr</var>. If <kbd><b>pthread_condattr_setclock()</b></kbd> is
called with a <var>clock_id</var> argument that refers to
a CPU-time clock, the call fails. The clock attribute is the clock ID of the
clock that is used to measure the timeout service of <kbd><b>pthread_cond_timedwait()</b></kbd>. The default value of the clock attribute refers to the system
clock, <tt>CLOCK_REALTIME</tt>.  At this time, the only other possible
value for  the clock attribute is <tt>CLOCK_MONOTONIC</tt>.</p>
<a name="6mba5vq32"></a><h3 class="sol">
<tt>pthread_condattr_setclock</tt> Syntax</h3>
<a name="indexterm-171"></a><a name=""></a><pre>int pthread_condattr_setclock(pthread_condattr_t <var>attr</var>, 
          clockid_t <var>clock_id</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;

pthread_condattr_t <var>attr</var>
clockid_t <var>clock_id</var>
int <var>ret</var>


<var>ret</var> = pthread_condattr_setclock(&amp;<var>attr</var> &amp;<var>clock_id</var>
</pre>
<a name="6mba5vq34"></a><h3 class="sol">
<tt>pthread_condattr_setclock</tt> Returns</h3>
<p>
<a name="indexterm-172"></a><kbd><b>pthread_condattr_setclock()</b></kbd>  returns zero after completing successfully. Any other return
value indicates that an error occurred. When the following condition occurs,
the function fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>clock_id</var> does
not refer to a known clock, or is a CPU-time clock.</p>


</dl><a name="6mba5vq36"></a><h2 class="sol">Getting the Clock Selection Condition Variable</h2>
<p>
<a name="indexterm-173"></a>Use the <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-condattr-getclock-3c/index.html">pthread_condattr_getclock(3C)</a> function
to obtain the value of the clock attribute from the attributes object referenced
by <var>attr</var>. The clock attribute is the clock ID of
the clock that is used to measure the timeout service of <kbd><b>pthread_cond_timedwait()</b></kbd>.</p>
<a name="6mba5vq38"></a><h3 class="sol">
<tt>pthread_condattr_getclock</tt> Syntax</h3>
<a name=""></a><pre>int pthread_condattr_getclock(const pthread_condattr_t *restrict <var>attr</var>,
          clockid_t *restrict <var>clock_id</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;

pthread_condattr_t <var>attr</var>
clockid_t <var>clock_id</var>
int <var>ret</var>


<var>ret</var> = pthread_condattr_getclock(&amp;<var>attr</var> &amp;<var>clock_id</var>
</pre>
<a name="6mba5vq3a"></a><h3 class="sol">
<tt>pthread_condattr_getclock</tt> Returns</h3>
<p>
<a name="indexterm-174"></a><kbd><b>pthread_condattr_getclock()</b></kbd>  returns zero after completing successfully and stores the value
of the <tt>clock</tt> attribute of <var>attr</var> into
the object referenced by the <var>clock_id</var> argument.
Any other return value indicates that an error occurred. When the following
condition occurs, the function fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value of <var>attr</var> is
invalid.</p>


</dl><a name="6mba5vq3c"></a><h1 class="sol">Using Condition Variables</h1>
<p>This section explains how to use condition variables.  <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq3c/index.html#sync-71474">Table 4–5</a> lists the functions that
are available.</p>
<a name="sync-71474"></a>Table 4–5  Condition Variables Functions<table width="100%" cellpadding="10" cellspacing="0" border="2">
<caption>
<b></b>
</caption>
<thead>
<tr>
<th scope="col" align="left" valign="top">
<p>Operation&nbsp;</p>

</th><th scope="col" align="left" valign="top">
<p>Related Function Description&nbsp;</p>

</th>
</tr>

</thead>
<tbody>
<tr>
<td align="left" valign="top">
<p>Initialize a condition variable&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-59145/index.html"><tt>pthread_cond_init</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Block on a condition variable&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-44265/index.html"><tt>pthread_cond_wait</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Unblock a specific thread&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-53686/index.html"><tt>pthread_cond_signal</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Block until a specified time&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-46756/index.html"><tt>pthread_cond_timedwait</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Block for a specified interval&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-120/index.html"><tt>pthread_cond_reltimedwait_np</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Unblock all threads&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-40617/index.html"><tt>pthread_cond_broadcast</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Destroy condition variable state&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-68029/index.html"><tt>pthread_cond_destroy</tt> Syntax</a>
</p>

</td>
</tr>

</tbody>
</table>
<p> 
</p><a name="6mba5vq3e"></a><h2 class="sol">Initializing a Condition Variable</h2>
<p>
<a name="indexterm-175"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-cond-init-3c/index.html">pthread_cond_init(3C)</a> to initialize the condition variable pointed at by <var>cv</var> to its default value, or to specify condition variable attributes
that are already set with  <kbd><b>pthread_condattr_init()</b></kbd>.</p>
<a name="6mba5vq3g"></a><h3 class="sol">
<tt>pthread_cond_init</tt> Syntax</h3>
<a name="sync-ix349"></a><a name=""></a><pre>int pthread_cond_init(pthread_cond_t *restrict <var>cv</var>,
          const pthread_condattr_t *restrict <var>cattr</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;

pthread_cond_t <var>cv</var>;
pthread_condattr_t <var>cattr</var>;
int <var>ret</var>;

/* initialize a condition variable to its default value */
<var>ret</var> = pthread_cond_init(&amp;<var>cv</var>, NULL);

/* initialize a condition variable */
<var>ret</var> = pthread_cond_init(&amp;<var>cv</var>, &amp;<var>cattr</var>); </pre>
<p>The effect of  <var>cattr</var> set to <tt>NULL</tt> is
the same as passing the address of a default condition variable attribute
object, but without the memory overhead.</p>
<p>Use the macro <tt>PTHREAD_COND_INITIALIZER</tt> to initialize
statically defined condition variables to their default attributes. The <tt>PTHREAD_COND_INITIALIZER</tt>  macro has the same effect as dynamically
allocating <kbd><b>pthread_cond_init()</b></kbd>  with null attributes. No
error checking is done.</p>
<p>Multiple threads must not simultaneously initialize or reinitialize
the same condition variable. If a condition variable is reinitialized or is
destroyed, the application must be sure that the condition variable is not
in use.</p>
<a name="6mba5vq3i"></a><h3 class="sol">
<tt>pthread_cond_init</tt> Return Values</h3>
<p>
<a name="indexterm-176"></a><kbd><b>pthread_cond_init()</b></kbd> returns
zero after completing successfully. Any other return value indicates that
an error occurred. When any of the following conditions occurs, the function
fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>cattr</var> is
invalid.</p>


<br>
<p>
<tt><samp>EBUSY</samp></tt>
</p>

<b>Description: </b>
<p>The condition variable is being used.</p>


<br>
<p>
<tt><samp>EAGAIN</samp></tt>
</p>

<b>Description: </b>
<p>The necessary resources are not available.</p>


<br>
<p>
<tt><samp>ENOMEM</samp></tt>
</p>

<b>Description: </b>
<p>Insufficient memory exists to initialize
the condition variable.</p>


</dl><a name="6mba5vq3k"></a><h2 class="sol">Blocking on a Condition Variable</h2>
<p>
<a name="indexterm-177"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-cond-wait-3c/index.html">pthread_cond_wait(3C)</a> to atomically release the
mutex pointed to by <var>mp</var> and to cause the calling
thread to block on the condition variable pointed to by  <var>cv</var>.</p>
<a name="6mba5vq3m"></a><h3 class="sol">
<tt>pthread_cond_wait</tt> Syntax</h3>
<a name="sync-ix354"></a><a name=""></a><pre>int pthread_cond_wait(pthread_cond_t *restrict <var>cv</var>,pthread_mutex_t *restrict <var>mutex</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;

pthread_cond_t <var>cv</var>;
pthread_mutex_t <var>mp</var>;
int <var>ret</var>;

/* wait on condition variable */
<var>ret</var> = pthread_cond_wait(&amp;<var>cv</var>, &amp;
<var>mp</var>); </pre>
<p>
<a name="sync-ix355"></a><a name="sync-ix356"></a>The blocked thread can be awakened by a <kbd><b>pthread_cond_signal()</b></kbd> , a <kbd><b>pthread_cond_broadcast()</b></kbd>, or when interrupted
by delivery of a signal.</p>
<p>Any change in the value of a condition that is associated with the condition
variable cannot be inferred by the return of <kbd><b>pthread_cond_wait()</b></kbd>.
Such conditions must be reevaluated.</p>
<p>The <kbd><b>pthread_cond_wait()</b></kbd> routine always returns with
the mutex locked and owned by the calling thread, even when returning an error.</p>
<p>This function blocks until the condition is signaled. The function atomically
releases the associated mutex lock before blocking, and atomically acquires
the mutex again before returning.</p>
<p>In typical use, a condition expression is evaluated under the protection
of a mutex lock. When the condition expression is false, the thread blocks
on the condition variable. The condition variable is then signaled by another
thread when the thread changes the condition value. The change causes at least
one thread that is waiting on the condition variable to unblock and to reacquire
the mutex.</p>
<p>The condition that caused the wait must be retested before continuing
execution from the point of the <kbd><b>pthread_cond_wait()</b></kbd>. The
condition could change before an awakened thread reacquires the mutes and
returns from  <kbd><b>pthread_cond_wait()</b></kbd>. A waiting thread could
be awakened spuriously. The recommended test method is to write the condition
check as a <kbd><b>while()</b></kbd> loop that calls <kbd><b>pthread_cond_wait()</b></kbd>.</p>
<a name=""></a><pre>    pthread_mutex_lock();
        while(condition_is_false)
            pthread_cond_wait();
    pthread_mutex_unlock();</pre>
<p>The scheduling policy determines the order in which blocked threads
are awakened. The default scheduling policy, <tt>SCHED_OTHER</tt>,
does not specify the order in which threads are awakened. Under the <tt>SCHED_FIFO</tt> and <tt>SCHED_RR</tt> real-time scheduling policies,
threads are awakened in priority order.</p>
<hr><b>Note – </b><p>
<kbd><b>pthread_cond_wait()</b></kbd> is a cancellation point.
If a cancel is pending and the calling thread has cancellation enabled, the
thread terminates and begins executing its cleanup handlers while continuing
to hold the lock.</p>
<hr>
<a name="6mba5vq3o"></a><h3 class="sol">
<tt>pthread_cond_wait</tt> Return Values</h3>
<p>
<a name="indexterm-178"></a><kbd><b>pthread_cond_wait()</b></kbd> returns
zero after completing successfully. Any other return value indicates that
an error occurred. When the following condition occurs, the function fails
and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>cv</var> or
 <var>mp</var> is invalid.</p>


</dl><a name="6mba5vq3q"></a><h2 class="sol">Unblocking One Thread</h2>
<p>
<a name="indexterm-179"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-cond-signal-3c/index.html">pthread_cond_signal(3C)</a> to unblock
one thread that is blocked on the condition variable pointed to by  <var>cv</var>. </p>
<a name="6mba5vq3s"></a><h3 class="sol">
<tt>pthread_cond_signal</tt> Syntax</h3>
<a name="sync-ix358"></a><a name=""></a><pre>int pthread_cond_signal(pthread_cond_t *<var>cv</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;

pthread_cond_t <var>cv</var>;
int <var>ret</var>;

/* one condition variable is signaled */
<var>ret</var> = pthread_cond_signal(&amp;<var>cv</var>); </pre>
<p>Modify the associated condition under the protection of the same mutex
used with the condition variable being signaled. Otherwise, the condition
 could be modified between its test and blocking in <kbd><b>pthread_cond_wait()</b></kbd>,
which can cause an infinite wait.</p>
<p>The scheduling policy determines the order in which blocked threads
are awakened. The default scheduling policy, <tt>SCHED_OTHER</tt>,
does not specify the order in which threads are awakened. Under the <tt>SCHED_FIFO</tt> and <tt>SCHED_RR</tt> real-time scheduling policies,
threads are awakened in priority order.</p>
<p>
<a name="sync-ix360"></a><a name="sync-ix361"></a>When no threads are blocked on the condition variable, calling <kbd><b>pthread_cond_signal()</b></kbd>  has no effect.</p>
<a name="sync-ex-23"></a><hr><h5 class="sol">Example 4–8  Using <kbd><b>pthread_cond_wait()</b></kbd> and
 <kbd><b>pthread_cond_signal()</b></kbd>
</h5><br><a name=""></a><pre>pthread_mutex_t count_lock;
pthread_cond_t count_nonzero;
unsigned count;

decrement_count()
{
    pthread_mutex_lock(&amp;count_lock);
    while (count == 0)
        pthread_cond_wait(&amp;count_nonzero, &amp;count_lock);
    count = count - 1;
    pthread_mutex_unlock(&amp;count_lock);
}

increment_count()
{
    pthread_mutex_lock(&amp;count_lock);
    if (count == 0)
        pthread_cond_signal(&amp;count_nonzero);
    count = count + 1;
    pthread_mutex_unlock(&amp;count_lock);
}</pre>
<hr>
<a name="6mba5vq3u"></a><h3 class="sol">
<tt>pthread_cond_signal</tt> Return
Values</h3>
<p>
<a name="indexterm-180"></a><kbd><b>pthread_cond_signal()</b></kbd> returns
zero after completing successfully. Any other return value indicates that
an error occurred. When the following condition occurs, the function fails
and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>
<var>cv</var> points to
an illegal address.</p>


</dl><p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq3s/index.html#sync-ex-23">Example 4–8</a> shows how
to use  <kbd><b>pthread_cond_wait()</b></kbd> and <kbd><b>pthread_cond_signal()</b></kbd>.</p>
<a name="6mba5vq40"></a><h2 class="sol">Blocking Until a Specified Time</h2>
<p>
<a name="indexterm-181"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-cond-timedwait-3c/index.html">pthread_cond_timedwait(3C)</a> as you would
use <kbd><b>pthread_cond_wait()</b></kbd>, except that <kbd><b>pthread_cond_timedwait()</b></kbd>  does not block past the time of day specified by <var>abstime</var> .</p>
<a name="6mba5vq42"></a><h3 class="sol">
<tt>pthread_cond_timedwait</tt> Syntax</h3>
<a name="sync-ix362"></a><a name=""></a><pre>int pthread_cond_timedwait(pthread_cond_t *restrict <var>cv</var>,
          pthread_mutex_t *restrict <var>mp</var>, 
          const struct timespec *restrict <var>abstime</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

pthread_cond_t <var>cv</var>;
pthread_mutex_t <var>mp</var>;
timestruct_t <var>abstime</var>;
int <var>ret</var>;

/* wait on condition variable */
<var>ret</var> = pthread_cond_timedwait(&amp;<var>cv</var>, &amp;
<var>mp</var>, &amp;<var>abstime</var>); </pre>
<p>
<kbd><b>pthread_cond_timedwait()</b></kbd> always returns with the
mutex locked and owned by the calling thread, even when <kbd><b>pthread_cond_timedwait()</b></kbd> is returning an error. </p>
<p>The <kbd><b>pthread_cond_timedwait()</b></kbd> function blocks until
the condition is signaled or until the time of day specified by the last argument
has passed.</p>
<hr><b>Note – </b><p>
<a name="sync-ix366"></a><kbd><b>pthread_cond_timedwait()</b></kbd> is
also a cancellation point.</p>
<hr>
<a name="sync-ex-25"></a><hr><a name="sync-17410"></a><h5 class="sol">Example 4–9  Timed Condition Wait</h5><br><a name=""></a><pre>pthread_timestruc_t to;
pthread_mutex_t m;
pthread_cond_t c;
...
pthread_mutex_lock(&amp;m);
clock_gettime(CLOCK_REALTIME, &amp;to);
to.tv_sec += TIMEOUT;
while (cond == FALSE) {
    err = pthread_cond_timedwait(&amp;c, &amp;m, &amp;to);
    if (err == ETIMEDOUT) {
        /* timeout, do something */
        break;
    }
}
pthread_mutex_unlock(&amp;m);</pre>
<hr>
<a name="6mba5vq44"></a><h3 class="sol">
<tt>pthread_cond_timedwait</tt> Return
Values</h3>
<p>
<a name="indexterm-182"></a><kbd><b>pthread_cond_timedwait()</b></kbd> returns
zero after completing successfully. Any other return value indicates that
an error occurred. When either of the following conditions occurs, the function
fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>
<var>cv</var>, <var>mp</var>, or  <var>abstime</var> points to an illegal
address.</p>


<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>Different mutexes were supplied for concurrent <kbd><b>pthread_cond_timedwait()</b></kbd> operations on the same condition variable.</p>


<br>
<p>
<tt><samp>ETIMEDOUT</samp></tt>
</p>

<b>Description: </b>
<p>The time specified by <var>abstime</var> has
passed.</p>


<br>
<p>
<tt><samp>EPERM</samp></tt>
</p>

<b>Description: </b>
<p>The mutex was not owned by the current
thread at the time of the call.</p>


</dl><p>
<a name="sync-ix365"></a>The timeout is specified as a time of day so that the condition
can be retested efficiently without recomputing the value, as shown in  <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq42/index.html#sync-ex-25">Example 4–9</a>.</p>
<a name="6mba5vq46"></a><h2 class="sol">Blocking For a Specified Interval</h2>
<p>
<a name="indexterm-183"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-cond-reltimedwait-np-3c/index.html">pthread_cond_reltimedwait_np(3C)</a> as you would
use <kbd><b>pthread_cond_timedwait()</b></kbd> with one exception.  <kbd><b>pthread_cond_reltimedwait_np()</b></kbd> takes a relative time interval rather than an absolute future
time of day as the value of its last argument.</p>
<a name="6mba5vq48"></a><h3 class="sol">
<tt>pthread_cond_reltimedwait_np</tt> Syntax</h3>
<a name="indexterm-184"></a><a name=""></a><pre>int pthread_cond_reltimedwait_np(pthread_cond_t *<var>cv</var>, 
           pthread_mutex_t *<var>mp</var>, 
          const struct timespec *<var>reltime</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;
#include &lt;time.h&gt; 
pthread_cond_t <var>cv</var>; 
pthread_mutex_t <var>mp</var>; 
timestruct_t <var>reltime</var>; 
int ret; 

/* wait on condition variable */ 
ret = pthread_cond_reltimedwait_np(&amp;<var>cv</var>, &amp;<var>mp</var>, &amp;<var>reltime</var>); </pre>
<p>
<kbd><b>pthread_cond_reltimedwait_np()</b></kbd> always returns with
the mutex locked and owned by the calling thread, even when <kbd><b>pthread_cond_reltimedwait_np()</b></kbd>  is returning an error.  The <kbd><b>pthread_cond_reltimedwait_np()</b></kbd> function
blocks until the condition is signaled or until the time interval specified
by the last argument has elapsed.</p>
<hr><b>Note – </b><p>
<kbd><b>pthread_cond_reltimedwait_np()</b></kbd> is also a cancellation
point.</p>
<hr>
<a name="6mba5vq4a"></a><h3 class="sol">
<tt>pthread_cond_reltimedwait_np</tt> Return
Values</h3>
<p>
<a name="indexterm-185"></a><kbd><b>pthread_cond_reltimedwait_np()</b></kbd>  returns zero after completing successfully. Any other return
value indicates that an error occurred. When either of the following conditions
occurs, the function fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>reltime</var> is
invalid.</p>


<br>
<p>
<tt><samp>ETIMEDOUT</samp></tt>
</p>

<b>Description: </b>
<p>The time interval specified by <var>reltime</var>  has passed.</p>


</dl><a name="6mba5vq4c"></a><h2 class="sol">Unblocking All Threads</h2>
<p>
<a name="indexterm-186"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-cond-broadcast-3c/index.html">pthread_cond_broadcast(3C)</a> to unblock
all threads that are blocked on the condition variable pointed to by  <var>cv</var>, specified by <kbd><b>pthread_cond_wait()</b></kbd>.</p>
<a name="6mba5vq4e"></a><h3 class="sol">
<tt>pthread_cond_broadcast</tt> Syntax</h3>
<a name="sync-ix367"></a><a name=""></a><pre>int pthread_cond_broadcast(pthread_cond_t *<var>cv</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;

pthread_cond_t <var>cv</var>;
int <var>ret</var>;

/* all condition variables are signaled */
<var>ret</var> = pthread_cond_broadcast(&amp;<var>cv</var>); </pre>
<p>When no threads are blocked on the condition variable, <kbd><b>pthread_cond_broadcast()</b></kbd>  has no effect.</p>
<p>
<a name="sync-ix369"></a>Since <kbd><b>pthread_cond_broadcast()</b></kbd> causes
all threads blocked on the condition to contend again for the mutex lock,
use  <kbd><b>pthread_cond_broadcast()</b></kbd> with care. For example, use <kbd><b>pthread_cond_broadcast()</b></kbd>  to allow threads to contend for varying
resource amounts when resources are freed, as shown in <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq4e/index.html#sync-ex-28">Example 4–10</a>.</p>
<a name="sync-ex-28"></a><hr><a name="sync-40421"></a><h5 class="sol">Example 4–10  Condition Variable Broadcast</h5><br><a name=""></a><pre>pthread_mutex_t rsrc_lock;
pthread_cond_t rsrc_add;
unsigned int resources;

get_resources(int amount)
{
    pthread_mutex_lock(&amp;rsrc_lock);
    while (resources &lt; amount) {
        pthread_cond_wait(&amp;rsrc_add, &amp;rsrc_lock);
    }
    resources -= amount;
    pthread_mutex_unlock(&amp;rsrc_lock);
}

add_resources(int amount)
{
    pthread_mutex_lock(&amp;rsrc_lock);
    resources += amount;
    pthread_cond_broadcast(&amp;rsrc_add);
    pthread_mutex_unlock(&amp;rsrc_lock);
}</pre>
<hr>
<p>Note that in <kbd><b>add_resources()</b></kbd> whether <b>resources</b>  are updated first, or if <kbd><b>pthread_cond_broadcast()</b></kbd> is
called first inside the mutex lock does not matter.</p>
<p>Modify the associated condition under the protection of the same mutex
that is used with the condition variable being signaled. Otherwise, the condition
 could be modified between its test and blocking in <kbd><b>pthread_cond_wait()</b></kbd>,
which can cause an infinite wait.</p>
<a name="6mba5vq4g"></a><h3 class="sol">
<tt>pthread_cond_broadcast</tt> Return
Values</h3>
<p>
<a name="indexterm-187"></a><kbd><b>pthread_cond_broadcast()</b></kbd> returns
zero after completing successfully. Any other return value indicates that
an error occurred. When the following condition occurs, the function fails
and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>
<var>cv</var> points to
an illegal address.</p>


</dl><a name="6mba5vq4i"></a><h2 class="sol">Destroying the Condition Variable State</h2>
<p>
<a name="indexterm-188"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-cond-destroy-3c/index.html">pthread_cond_destroy(3C)</a> to destroy
any state that is associated with the condition variable pointed to by  <var>cv</var>.</p>
<a name="6mba5vq4k"></a><h3 class="sol">
<tt>pthread_cond_destroy</tt> Syntax</h3>
<a name="sync-ix370"></a><a name=""></a><pre>int pthread_cond_destroy(pthread_cond_t *<var>cv</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt;

pthread_cond_t <var>cv</var>;
int <var>ret</var>;

/* Condition variable is destroyed */
<var>ret</var> = pthread_cond_destroy(&amp;<var>cv</var>); </pre>
<p>Note that the space for storing the condition variable is not freed.</p>
<a name="6mba5vq4m"></a><h3 class="sol">
<tt>pthread_cond_destroy</tt> Return
Values</h3>
<p>
<a name="indexterm-189"></a><kbd><b>pthread_cond_destroy()</b></kbd> returns
zero after completing successfully. Any other return value indicates that
an error occurred. When the following condition occurs, the function fails
and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>cv</var> is
invalid.</p>


</dl><a name="6mba5vq4o"></a><h2 class="sol">Lost Wake-Up Problem</h2>
<p>
<a name="sync-ix372"></a><a name="sync-ix373"></a><a name="indexterm-190"></a>A call to <kbd><b>pthread_cond_signal()</b></kbd> or <kbd><b>pthread_cond_broadcast()</b></kbd> 
when the thread does not hold the mutex lock associated with the condition
can lead to <b>lost wake-up</b> bugs.</p>
<p>A lost wake-up occurs when all of the following conditions are in effect:</p>
<a name=""></a><ul>
<li>
<p>A thread calls <kbd><b>pthread_cond_signal()</b></kbd> or
 <kbd><b>pthread_cond_broadcast()</b></kbd>
</p>


</li>
<li>
<p>
<a name="sync-ix374"></a>Another thread is between the test of the condition and the call
to  <kbd><b>pthread_cond_wait()</b></kbd>
</p>


</li>
<li>
<p>No threads are waiting</p>

<p>The signal has no effect,
and therefore is lost</p>


</li>
</ul>
<p>This can occur only if the condition being tested is modified without
holding the mutex lock associated with the condition. As long as the condition
being tested is modified only while holding the associated mutex, <kbd><b>pthread_cond_signal()</b></kbd>  and <kbd><b>pthread_cond_broadcast()</b></kbd> can be called
regardless of whether they are holding the associated mutex.</p>
<a name="6mba5vq4p"></a><h2 class="sol">Producer and Consumer Problem</h2>
<p>The producer and consumer problem is one of the small collection of
standard, well-known problems in concurrent programming. A finite-size buffer
and two classes of threads, producers and consumers, put items into the buffer
(producers) and take items out of the buffer (consumers).</p>
<p>A producer cannot put something in the buffer until the buffer has space
available. A consumer cannot take something out of the buffer until the producer
has written to the buffer.</p>
<p>A condition variable represents a queue of threads that wait for some
condition to be signaled.</p>
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq4p/index.html#sync-30944">Example 4–11</a> has two
such queues. One (<var>less</var>) queue for producers waits
for a slot in the buffer. The other (<var>more</var>) queue
for consumers waits for a buffer slot containing information. The example
also has a mutex, as the data structure describing the buffer must be accessed
by only one thread at a time.</p>
<a name="sync-30944"></a><hr><h5 class="sol">Example 4–11  Producer and Consumer Problem With Condition
Variables</h5><br><a name=""></a><pre>typedef struct { 
     char buf[BSIZE]; 
     int occupied; 
     int nextin; 
     int nextout; 
     pthread_mutex_t mutex; 
     pthread_cond_t more; 
     pthread_cond_t less; } 
buffer_t; 

buffer_t buffer;</pre>
<hr>
<p>
<a name="sync-ix375"></a>As <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq4p/index.html#sync-ex-32">Example 4–12</a> shows,
the producer thread acquires the mutex protecting the <kbd>buffer</kbd> data
structure. The producer thread then makes certain that space is available
for the item produced. If space is not available, the producer thread calls <kbd><b>pthread_cond_wait()</b></kbd> . <kbd><b>pthread_cond_wait()</b></kbd> causes
the producer thread to join the queue of threads that are waiting for the
condition <var>less</var> to be signaled. <var>less</var> represents
available room in the buffer.</p>
<p>At the same time, as part of the call to <kbd><b>pthread_cond_wait()</b></kbd>,
the thread releases its lock on the mutex. The waiting producer threads depend
on consumer threads to signal when the condition is true, as shown in  <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq4p/index.html#sync-ex-32">Example 4–12</a>. When the condition
is signaled, the first thread waiting on <var>less</var> is
awakened. However, before the thread can return from <kbd><b>pthread_cond_wait()</b></kbd>,
the thread must acquire the lock on the mutex again.</p>
<p>Acquire the mutex to ensure that the thread again has mutually exclusive
access to the buffer data structure. The thread then must check that available
room in the buffer actually exists. If room is available, the thread writes
into the next available slot.</p>
<p>
<a name="sync-ix376"></a>At the same time, consumer threads might be waiting for items
to appear in the buffer. These threads are waiting on the condition variable <var>more</var> . A producer thread, having just deposited something in
the buffer, calls <kbd><b>pthread_cond_signal()</b></kbd> to wake up the
next waiting consumer. If no consumers are waiting, this call has no effect.</p>
<p>Finally, the producer thread unlocks the mutex, allowing other threads
to operate on the buffer data structure.</p>
<a name="sync-ex-32"></a><hr><h5 class="sol">Example 4–12  The Producer and Consumer Problem: the Producer</h5><br><a name=""></a><pre>void producer(buffer_t *b, char item)
{
    pthread_mutex_lock(&amp;b-&gt;mutex);
   
    while (b-&gt;occupied &gt;= BSIZE)
        pthread_cond_wait(&amp;b-&gt;less, &amp;b-&gt;mutex);

    assert(b-&gt;occupied &lt; BSIZE);

    b-&gt;buf[b-&gt;nextin++] = item;

    b-&gt;nextin %= BSIZE;
    b-&gt;occupied++;

    /* now: either b-&gt;occupied &lt; BSIZE and b-&gt;nextin is the index
       of the next empty slot in the buffer, or
       b-&gt;occupied == BSIZE and b-&gt;nextin is the index of the
       next (occupied) slot that will be emptied by a consumer
       (such as b-&gt;nextin == b-&gt;nextout) */

    pthread_cond_signal(&amp;b-&gt;more);

    pthread_mutex_unlock(&amp;b-&gt;mutex);
}</pre>
<hr>
<p>
<a name="sync-ix377"></a><a name="sync-ix378"></a>Note
the use of the <kbd><b>assert()</b></kbd> statement. Unless the code is compiled
with  <tt>NDEBUG</tt> defined, <kbd><b>assert()</b></kbd> does
nothing when its argument evaluates to true (nonzero). The program aborts
if the argument evaluates to false (zero). Such assertions are especially
useful in multithreaded programs.  <kbd><b>assert()</b></kbd> immediately
points out runtime problems if the assertion fails.  <kbd><b>assert()</b></kbd> has
the additional effect of providing useful comments.</p>
<p>The comment that begins <tt>/* now: either b-&gt;occupied ...</tt> could
better be expressed as an assertion, but the statement is too complicated
as a Boolean-valued expression and so is given in English.</p>
<p>
<a name="sync-ix379"></a><a name="sync-ix380"></a>Both assertions
and comments are examples of invariants. These invariants are logical statements
that should not be falsified by the execution of the program with the following
exception. The exception occurs during brief moments when a thread is modifying
some of the program variables mentioned in the invariant. An assertion, of
course, should be true whenever any thread executes the statement.</p>
<p>The use of invariants is an extremely useful technique. Even if the
invariants are not stated in the program text, think in terms of invariants
when you analyze a program.</p>
<p>The invariant in the producer code that is expressed as a comment is
always true whenever a thread executes the code where the comment appears.
If you move this comment to just after the <kbd><b>mutex_unlock()</b></kbd>,
the comment does not necessarily remain true. If you move this comment to
just after the <kbd><b>assert()</b></kbd> , the comment is still true.</p>
<p>This invariant therefore expresses a property that is true at all times
with the following exception. The exception occurs when either a producer
or a consumer is changing the state of the buffer. While a thread is operating
on the buffer under the protection of a mutex, the thread might temporarily
falsify the invariant. However, once the thread is finished, the invariant
should be true again.</p>
<p>
<a name="sync-ix381"></a><a name="sync-ix382"></a><a name="sync-ix383"></a><a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq4p/index.html#sync-ex-33">Example 4–13</a> shows the code for
the consumer. The logic flow is symmetric with the logic flow of the producer.</p>
<a name="sync-ex-33"></a><hr><h5 class="sol">Example 4–13  The Producer and Consumer Problem: the Consumer</h5><br><a name=""></a><pre>char consumer(buffer_t *b)
{
    char item;
    pthread_mutex_lock(&amp;b-&gt;mutex);
    while(b-&gt;occupied &lt;= 0)
        pthread_cond_wait(&amp;b-&gt;more, &amp;b-&gt;mutex);

    assert(b-&gt;occupied &gt; 0);

    item = b-&gt;buf[b-&gt;nextout++];
    b-&gt;nextout %= BSIZE;
    b-&gt;occupied--;

    /* now: either b-&gt;occupied &gt; 0 and b-&gt;nextout is the index
       of the next occupied slot in the buffer, or
       b-&gt;occupied == 0 and b-&gt;nextout is the index of the next
       (empty) slot that will be filled by a producer (such as
       b-&gt;nextout == b-&gt;nextin) */

    pthread_cond_signal(&amp;b-&gt;less);
    pthread_mutex_unlock(&amp;b-&gt;mutex);

    return(item);
}</pre>
<hr>
<a name="6mba5vq4q"></a><h1 class="sol">Synchronization With Semaphores</h1>
<a name="sync-ix384"></a><a name="sync-ix385"></a><a name="indexterm-191"></a><p>
<a name="sync-ix386"></a>A
semaphore is a programming construct designed by E. W. Dijkstra in the late
1960s. Dijkstra's model was the operation of railroads. Consider a stretch
of railroad where a single track is present over which only one train at a
time is allowed.</p>
<p>A semaphore synchronizes travel on this track. A train must wait before
entering the single track until the semaphore is in a state that permits travel.
When the train enters the track, the semaphore changes state to prevent other
trains from entering the track. A train that is leaving this section of track
must again change the state of the semaphore to allow another train to enter.</p>
<p>
<a name="sync-ix387"></a>In the computer version, a semaphore
appears to be a simple integer. A thread waits for permission to proceed and
then signals that the thread has proceeded by performing a <tt>P</tt> operation
on the semaphore.</p>
<p>
<a name="sync-ix388"></a>The thread must wait until the semaphore's
value is positive, then change the semaphore's value by subtracting 1 from
the value. When this operation is finished, the thread performs a <tt>V</tt> operation,
which changes the semaphore's value by adding 1 to the value. These operations
must take place atomically. These operations cannot be subdivided into pieces
between which other actions on the semaphore can take place. In the <tt>P</tt> operation,
the semaphore's value must be positive just before the value is decremented,
resulting in a value that is guaranteed to be nonnegative and 1 less than
what it was before it was decremented.</p>
<p>In both <tt>P</tt> and <tt>V</tt> operations, the
arithmetic must take place without interference. The net effect of two <tt>V</tt> operations performed simultaneously on the same semaphore, should
be that the semaphore's new value is 2 greater than it was.</p>
<p>
<a name="sync-ix389"></a><a name="sync-ix390"></a>The mnemonic significance of <tt>P</tt> and <tt>V</tt> is unclear to most of the world, as Dijkstra
is Dutch. However, in the interest of true scholarship: <tt>P</tt> stands
for prolagen, a made-up word derived from proberen te verlagen, which means <b>try to decrease</b>.  <tt>V</tt> stands for verhogen, which
means <b>increase</b>. The mnemonic significance is discussed
in one of Dijkstra's technical notes, EWD 74.</p>
<p>
<a name="indexterm-192"></a><a name="sync-ix391"></a><a name="sync-ix392"></a><kbd>sem_wait</kbd>(3RT) and <kbd>sem_post</kbd>(3RT) correspond to
Dijkstra's  <tt>P</tt> and <tt>V</tt> operations. <kbd>sem_trywait</kbd>(3RT) is a conditional form of the <tt>P</tt> operation.
If the calling thread cannot decrement the value of the semaphore without
waiting, the call to returns immediately with a nonzero value.</p>
<p>
<a name="sync-ix393"></a><a name="indexterm-193"></a><a name="sync-ix394"></a><a name="sync-ix395"></a>The two basic sorts of semaphores are binary semaphores and counting
semaphores. Binary semaphores never take on values other than zero or one,
and counting semaphores take on arbitrary nonnegative values. A binary semaphore
is logically just like a mutex.</p>
<p>However, although not always enforced, mutexes should be unlocked only
by the thread that holds the lock. Because no notion exists of “the
thread that holds the semaphore,” any thread can perform a <tt>V</tt> or <kbd>sem_post</kbd> (3RT) operation.</p>
<p>Counting semaphores are nearly as powerful as conditional variables
when used in conjunction with mutexes. In many cases, the code might be simpler
when implemented with counting semaphores rather than with condition variables,
as shown in <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq5v/index.html#sync-27385">Example 4–14</a>,
 <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq5v/index.html#sync-ex-44">Example 4–15</a>, and <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq5v/index.html#sync-ex-45">Example 4–16</a>.</p>
<p>However, when a mutex is used with condition variables, an implied bracketing
is present. The bracketing clearly delineates which part of the program is
being protected. This behavior is not necessarily the case for a semaphore,
which might be called the  <b>go to</b> of concurrent programming.
A semaphore is powerful but too easy to use in an unstructured, indeterminate
way.</p>
<a name="6mba5vq4s"></a><h2 class="sol">Named and Unnamed Semaphores</h2>
<p>
<a name="indexterm-194"></a>POSIX semaphores can be unnamed or named. Unnamed semaphores are
allocated in process memory and initialized. Unnamed semaphores might be usable
by more than one process, depending on how the semaphore is allocated and
initialized. Unnamed semaphores are either private, inherited through <kbd><b>fork()</b></kbd>, or are protected by access protections of the regular file in
which they are allocated and mapped.</p>
<p>
<a name="indexterm-195"></a>Named semaphores are like process-shared semaphores, except that
named semaphores are referenced with a pathname rather than a <var>pshared</var> value. Named semaphores are sharable by several processes.
Named semaphores have an owner user-id, group-id, and a protection mode.</p>
<p>The functions <kbd>sem_open</kbd>, <kbd>sem_getvalue</kbd>,
 <kbd>sem_close</kbd>, and <kbd>sem_unlink</kbd> are available
to  <tt>open</tt>, <tt>retrieve</tt>, <tt>close</tt>,
and  <tt>remove</tt> named semaphores. By using <kbd>sem_open</kbd>,
you can create a named semaphore that has a name defined in the file system
name space.</p>
<p>For more information about named semaphores, see the <kbd>sem_open</kbd>,
 <kbd>sem_getvalue</kbd>, <kbd>sem_close</kbd>, and <kbd>sem_unlink</kbd> man pages.</p>
<a name="6mba5vq4t"></a><h2 class="sol">Counting Semaphores Overview</h2>
<p>Conceptually, a semaphore is a nonnegative integer count. Semaphores
are typically used to coordinate access to resources, with the semaphore count
initialized to the number of free resources. Threads then atomically increment
the count when resources are added and atomically decrement the count when
resources are removed.</p>
<p>When the semaphore count becomes zero, no more resources are present.
Threads that try to decrement the semaphore when the count is zero block until
the count becomes greater than zero.</p>
<a name="sync-tbl-35"></a>Table 4–6  Routines for Semaphores<table width="100%" cellpadding="10" cellspacing="0" border="2">
<caption>
<b></b>
</caption>
<thead>
<tr>
<th scope="col" align="left" valign="top">
<p>Operation&nbsp;</p>

</th><th scope="col" align="left" valign="top">
<p>Related Function Description&nbsp;</p>

</th>
</tr>

</thead>
<tbody>
<tr>
<td align="left" valign="top">
<p>Initialize a semaphore&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-19683/index.html"><tt>sem_init</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Increment a semaphore&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-93728/index.html"><tt>sem_post</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Block on a semaphore count&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-91984/index.html"><tt>sem_wait</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Decrement a semaphore count&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-87966/index.html"><tt>sem_trywait</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Destroy the semaphore state&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-59226/index.html"><tt>sem_destroy</tt> Syntax</a>
</p>

</td>
</tr>

</tbody>
</table>
<p> 
</p><p>
<a name="sync-ix396"></a><a name="sync-ix397"></a><a name="sync-ix398"></a>Because semaphores
need not be acquired and be released by the same thread, semaphores can be
used for asynchronous event notification, such as in signal handlers. And,
because semaphores contain state, semaphores can be used asynchronously without
acquiring a mutex lock as is required by condition variables. However, semaphores
are not as efficient as mutex locks.</p>
<p>The scheduling policy determines the order in which blocked threads
are awakened. The default scheduling policy, <tt>SCHED_OTHER</tt>,
does not specify the order in which threads are awakened. Under the <tt>SCHED_FIFO</tt> and <tt>SCHED_RR</tt> real-time scheduling policies,
threads are awakened in priority order.</p>
<p>Semaphores must be initialized before use, however semaphores do not
have attributes.</p>
<a name="6mba5vq4u"></a><h2 class="sol">Initializing a Semaphore</h2>
<p>
<a name="indexterm-196"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5171/sem-init-3rt/index.html">sem_init(3RT)</a> to
initialize the unnamed semaphore variable pointed to by <var>sem</var> to
 <var>value</var> amount.</p>
<a name="6mba5vq50"></a><h3 class="sol">
<tt>sem_init</tt> Syntax</h3>
<a name="sync-ix399"></a><a name=""></a><pre>int sem_init(sem_t *<var>sem</var>, int <var>pshared</var>, unsigned int <var>value</var>);</pre>
<a name=""></a><pre>#include &lt;semaphore.h&gt;

sem_t <var>sem</var>;
int <var>pshared</var>;
int <var>ret</var>;
int <var>value</var>;

/* initialize a private semaphore */
<var>pshared</var> = 0;
<var>value</var> = 1;
<var>ret</var> = sem_init(&amp;<var>sem</var>, <var>pshared</var>, <var>value</var>); </pre>
<p>If the value of <var>pshared</var> is zero, then the
semaphore cannot be shared between processes. If the value of <var>pshared</var> is nonzero, then the semaphore can be shared between processes.</p>
<p>Multiple threads must not initialize the same semaphore.</p>
<p>A semaphore must not be reinitialized while other threads might be using
the semaphore.</p>
<a name="6mba5vq53"></a><h4 class="sol">Initializing Semaphores With Intraprocess Scope</h4><p>
<a name="indexterm-197"></a>When <var>pshared</var> is 0, the semaphore can
be used by all the threads in this process only.</p>
<a name=""></a><pre>#include &lt;semaphore.h&gt;

sem_t <var>sem</var>;
int <var>ret</var>;
int count = 4;

/* to be used within this process only */
<var>ret</var> = sem_init(&amp;<var>sem</var>, 0, count); </pre>

<a name="6mba5vq54"></a><h4 class="sol">Initializing Semaphores With Interprocess Scope</h4><p>
<a name="indexterm-198"></a>When <var>pshared</var> is nonzero, the semaphore
can be shared by other processes.</p>
<a name=""></a><pre>#include &lt;semaphore.h&gt;

sem_t <var>sem</var>;
int <var>ret</var>;
int count = 4;

/* to be shared among processes */
<var>ret</var> = sem_init(&amp;<var>sem</var>, 1, count);</pre>

<a name="6mba5vq55"></a><h3 class="sol">
<tt>sem_init</tt> Return Values</h3>
<p>
<a name="indexterm-199"></a><kbd><b>sem_init()</b></kbd> returns zero after
completing successfully. Any other return value indicates that an error occurred.
When any of the following conditions occurs, the function fails and returns
the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value argument exceeds <tt>SEM_VALUE_MAX</tt> .</p>


<br>
<p>
<tt><samp>ENOSPC</samp></tt>
</p>

<b>Description: </b>
<p>A resource that is required to initialize
the semaphore has been exhausted. The limit on semaphores <tt>SEM_NSEMS_MAX</tt> has
been reached.</p>


<br>
<p>
<tt><samp>EPERM</samp></tt>
</p>

<b>Description: </b>
<p>The process lacks the appropriate privileges
to initialize the semaphore.</p>


</dl><a name="6mba5vq57"></a><h2 class="sol">Incrementing a Semaphore</h2>
<p>
<a name="indexterm-200"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5171/sem-post-3rt/index.html">sem_post(3RT)</a> to
atomically increment the semaphore pointed to by <var>sem</var>.</p>
<a name="6mba5vq59"></a><h3 class="sol">
<tt>sem_post</tt> Syntax</h3>
<a name="sync-ix403"></a><a name=""></a><pre>int sem_post(sem_t *<var>sem</var>);</pre>
<a name=""></a><pre>#include &lt;semaphore.h&gt;

sem_t <var>sem</var>;
int <var>ret</var>;

<var>ret</var> = sem_post(&amp;<var>sem</var>); /* semaphore is posted */</pre>
<p>When any threads are blocked on the semaphore, one of the threads is
unblocked. </p>
<a name="6mba5vq5b"></a><h3 class="sol">
<tt>sem_post</tt> Return Values</h3>
<p>
<a name="indexterm-201"></a><kbd><b>sem_post()</b></kbd> returns zero after
completing successfully. Any other return value indicates that an error occurred.
When the following condition occurs, the function fails and returns the corresponding
value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>
<var>sem</var> points
to an illegal address.</p>


</dl><a name="6mba5vq5d"></a><h2 class="sol">Blocking on a Semaphore Count</h2>
<p>
<a name="indexterm-202"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5171/sem-wait-3rt/index.html">sem_wait(3RT)</a> to block the calling thread
until the semaphore count pointed to by <var>sem</var>  becomes
greater than zero, then atomically decrement the count.</p>
<a name="6mba5vq5f"></a><h3 class="sol">
<tt>sem_wait</tt> Syntax</h3>
<a name="sync-ix405"></a><a name=""></a><pre>int sem_wait(sem_t *<var>sem</var>);</pre>
<a name=""></a><pre>#include &lt;semaphore.h&gt;

sem_t <var>sem</var>;
int <var>ret</var>;

ret = sem_wait(&amp;<var>sem</var>); /* wait for semaphore */</pre>
<a name="6mba5vq5h"></a><h3 class="sol">
<tt>sem_wait</tt> Return Values</h3>
<p>
<a name="indexterm-203"></a><kbd><b>sem_wait()</b></kbd> returns zero after
completing successfully. Any other return value indicates that an error occurred.
When any of the following conditions occurs, the function fails and returns
the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>
<var>sem</var> points
to an illegal address.</p>


<br>
<p>
<tt><samp>EINTR</samp></tt>
</p>

<b>Description: </b>
<p>A signal interrupted this function.</p>


</dl><a name="6mba5vq5j"></a><h2 class="sol">Decrementing a Semaphore Count</h2>
<p>
<a name="indexterm-204"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5171/sem-trywait-3rt/index.html">sem_trywait(3RT)</a> to try to atomically decrement the count in the semaphore
pointed to by  <var>sem</var> when the count is greater than
zero.</p>
<a name="6mba5vq5l"></a><h3 class="sol">
<tt>sem_trywait</tt> Syntax</h3>
<a name="sync-ix408"></a><a name=""></a><pre>int sem_trywait(sem_t *<var>sem</var>);</pre>
<a name=""></a><pre>#include &lt;semaphore.h&gt;

sem_t <var>sem</var>;
int <var>ret</var>;

<var>ret</var> = sem_trywait(&amp;<var>sem</var>); /* try to wait for semaphore*/</pre>
<p>This function is a nonblocking version of <kbd><b>sem_wait()</b></kbd>.
 <kbd><b>sem_trywait()</b></kbd> returns immediately if unsuccessful.</p>
<a name="6mba5vq5n"></a><h3 class="sol">
<tt>sem_trywait</tt> Return Values</h3>
<p>
<a name="indexterm-205"></a><kbd><b>sem_trywait()</b></kbd> returns zero
after completing successfully. Any other return value indicates that an error
occurred. When any of the following conditions occurs, the function fails
and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>
<var>sem</var> points
to an illegal address.</p>


<br>
<p>
<tt><samp>EINTR</samp></tt>
</p>

<b>Description: </b>
<p>A signal interrupted this function.</p>


<br>
<p>
<tt><samp>EAGAIN</samp></tt>
</p>

<b>Description: </b>
<p>The semaphore was already locked, so the
semaphore cannot be immediately locked by the <kbd><b>sem_trywait()</b></kbd> operation.</p>


</dl><a name="6mba5vq5p"></a><h2 class="sol">Destroying the Semaphore State</h2>
<p>
<a name="indexterm-206"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5171/sem-destroy-3rt/index.html">sem_destroy(3RT)</a> to destroy any state that is associated with the unnamed
semaphore pointed to by  <var>sem</var>.</p>
<a name="6mba5vq5r"></a><h3 class="sol">
<tt>sem_destroy</tt> Syntax</h3>
<a name="sync-ix412"></a><a name=""></a><pre>int sem_destroy(sem_t *<var>sem</var>);</pre>
<a name=""></a><pre>#include &lt;semaphore.h&gt;

sem_t <var>sem</var>;
int <var>ret</var>;

<var>ret</var> = sem_destroy(&amp;<var>sem</var>); /* the semaphore is destroyed */</pre>
<p>The space for storing the semaphore is not freed.</p>
<a name="6mba5vq5t"></a><h3 class="sol">
<tt>sem_destroy</tt> Return Values</h3>
<p>
<a name="indexterm-207"></a><kbd><b>sem_destroy()</b></kbd> returns zero
after completing successfully. Any other return value indicates that an error
occurred. When the following condition occurs, the function fails and returns
the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>
<var>sem</var> points
to an illegal address.</p>


</dl><a name="6mba5vq5v"></a><h2 class="sol">Producer and Consumer Problem Using Semaphores</h2>
<p>
<a name="indexterm-208"></a><a name="sync-ix414"></a>The data structure in <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq5v/index.html#sync-27385">Example 4–14</a>  is similar to the structure used
for the condition variables example, shown in <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq4p/index.html#sync-30944">Example 4–11</a>. Two semaphores represent the number
of full and empty buffers. The semaphores ensure that producers wait until
buffers are empty and that consumers wait until buffers are full.</p>
<a name="sync-27385"></a><hr><h5 class="sol">Example 4–14  Producer and Consumer Problem With Semaphores</h5><br><a name=""></a><pre>typedef struct {
    char buf[BSIZE];
    sem_t occupied;
    sem_t empty;
    int nextin;
    int nextout;
    sem_t pmut;
    sem_t cmut;
} buffer_t;

buffer_t buffer;

sem_init(&amp;buffer.occupied, 0, 0);
sem_init(&amp;buffer.empty,0, BSIZE);
sem_init(&amp;buffer.pmut, 0, 1);
sem_init(&amp;buffer.cmut, 0, 1);
buffer.nextin = buffer.nextout = 0;</pre>
<hr>
<p>
<a name="sync-ix415"></a><a name="sync-ix416"></a>Another
pair of binary semaphores plays the same role as mutexes. The semaphores control
access to the buffer when multiple producers use multiple empty buffer slots,
and when multiple consumers use multiple full buffer slots. Mutexes would
work better here, but would not provide as good an example of semaphore use.</p>
<a name="sync-ex-44"></a><hr><h5 class="sol">Example 4–15  Producer and Consumer Problem: the Producer</h5><br><a name=""></a><pre>void producer(buffer_t *b, char item) {
    sem_wait(&amp;b-&gt;empty);
    sem_wait(&amp;b-&gt;pmut);

    b-&gt;buf[b-&gt;nextin] = item;
    b-&gt;nextin++;
    b-&gt;nextin %= BSIZE;

    sem_post(&amp;b-&gt;pmut);
    sem_post(&amp;b-&gt;occupied);
}</pre>
<hr>
<a name="sync-ex-45"></a><hr><h5 class="sol">Example 4–16  Producer and Consumer Problem: the Consumer</h5><br><a name=""></a><pre>char consumer(buffer_t *b) {
    char item;

    sem_wait(&amp;b-&gt;occupied);
   
    sem_wait(&amp;b-&gt;cmut);

    item = b-&gt;buf[b-&gt;nextout];
    b-&gt;nextout++;
    b-&gt;nextout %= BSIZE;

    sem_post(&amp;b-&gt;cmut);

    sem_post(&amp;b-&gt;empty);

    return(item);
}</pre>
<hr>
<a name="6mba5vq60"></a><h1 class="sol">Read-Write Lock Attributes</h1>
<p>
<a name="indexterm-209"></a><a name="indexterm-210"></a>Read-write locks permit concurrent
reads and exclusive writes to a protected shared resource. The read-write
lock is a single entity that can be locked in <b>read</b> or <b>write</b> mode. To modify a resource, a thread must first acquire the
exclusive write lock. An exclusive write lock is not permitted until all read
locks have been released.</p>
<p>Database access can be synchronized with a read-write lock. Read-write
locks support concurrent reads of database records because the read operation
does not change the record's information. When the database is to be updated,
the write operation must acquire an exclusive write lock.</p>
<p>To change the default read-write lock attributes, you can declare and
initialize an attribute object. Often, the read-write lock attributes are
set up in one place at the beginning of the application. Set up at the beginning
of the application makes the attributes easier to locate and modify. The following
table lists the functions discussed in this section that manipulate read-write
lock attributes.</p>
<a name="sync-tbl-61"></a>Table 4–7  Routines for Read-Write Lock
Attributes<table width="100%" cellpadding="10" cellspacing="0" border="2">
<caption>
<b></b>
</caption>
<thead>
<tr>
<th scope="col" align="left" valign="top">
<p>Operation&nbsp;</p>

</th><th scope="col" align="left" valign="top">
<p>Related Function Description&nbsp;</p>

</th>
</tr>

</thead>
<tbody>
<tr>
<td align="left" valign="top">
<p>Initialize a read-write lock attribute&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-54/index.html"><tt>pthread_rwlockattr_init</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Destroy a read-write lock attribute&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-56/index.html"><tt>pthread_rwlockattr_destroy</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Set a read-write lock attribute&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-58/index.html"><tt>pthread_rwlockattr_setpshared</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Get a read-write lock attribute&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-60/index.html"><tt>pthread_rwlockattr_getpshared</tt> Syntax</a>
</p>

</td>
</tr>

</tbody>
</table>
<p> 
</p><a name="6mba5vq62"></a><h2 class="sol">Initializing a Read-Write Lock Attribute</h2>
<p>
<a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-rwlockattr-init-3c/index.html">pthread_rwlockattr_init(3C)</a> initializes a read-write lock attributes object <var>attr</var> with the default value for all of the attributes defined
by the implementation.</p>
<a name="6mba5vq64"></a><h3 class="sol">
<tt>pthread_rwlockattr_init</tt> Syntax</h3>
<a name="indexterm-211"></a><a name=""></a><pre>#include &lt;pthread.h&gt;

int pthread_rwlockattr_init(pthread_rwlockattr_t *<var>attr</var>);</pre>
<p>
<a name="indexterm-212"></a>Results are undefined if <kbd>pthread_rwlockattr_init</kbd> is called specifying an already initialized read-write lock attributes
object. After a read-write lock attributes object initializes one or more
read-write locks, any function that affects the object, including destruction,
does not affect previously initialized read-write locks.</p>
<a name="6mba5vq66"></a><h3 class="sol">
<tt>pthread_rwlockattr_init</tt> Return
Values</h3>
<p>
<a name="indexterm-213"></a>If successful, <kbd><b>pthread_rwlockattr_init()</b></kbd>  returns zero. Otherwise, an error number is returned to indicate
the error.</p>
<dl>
<br>
<p>
<tt><samp>ENOMEM</samp></tt>
</p>

<b>Description: </b>
<p>Insufficient memory exists to initialize
the read-write attributes object.</p>


</dl><a name="6mba5vq68"></a><h2 class="sol">Destroying a Read-Write Lock Attribute</h2>
<p>
<a name="indexterm-214"></a><a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-rwlockattr-destroy-3c/index.html">pthread_rwlockattr_destroy(3C)</a> destroys
a read-write lock attributes object.</p>
<a name="6mba5vq6a"></a><h3 class="sol">
<tt>pthread_rwlockattr_destroy</tt> Syntax</h3>
<a name="indexterm-215"></a><a name=""></a><pre>#include &lt;pthread.h&gt;

int pthread_rwlockattr_destroy(pthread_rwlockattr_t *<var>attr</var>);</pre>
<p>The effect of subsequent use of the object is undefined until the object
is re-initialized by another call to <kbd><b>pthread_rwlockattr_init()</b></kbd>.
An implementation can cause <kbd><b>pthread_rwlockattr_destroy()</b></kbd> to
set the object referenced by <var>attr</var> to an invalid
value.</p>
<a name="6mba5vq6c"></a><h3 class="sol">
<tt>pthread_rwlockattr_destroy</tt> Return
Values</h3>
<p>
<a name="indexterm-216"></a>If successful, <kbd><b>pthread_rwlockattr_destroy()</b></kbd>  returns zero. Otherwise, an error number is returned to indicate
the error.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>attr</var> is
invalid.</p>


</dl><a name="6mba5vq6e"></a><h2 class="sol">Setting a Read-Write Lock Attribute</h2>
<p>
<a name="indexterm-217"></a><a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-rwlockattr-setpshared-3c/index.html">pthread_rwlockattr_setpshared(3C)</a> sets the
process-shared read-write lock attribute.</p>
<a name="6mba5vq6g"></a><h3 class="sol">
<tt>pthread_rwlockattr_setpshared</tt> Syntax</h3>
<a name=""></a><pre>#include &lt;pthread.h&gt;
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *<var>attr</var>, int <var>pshared</var>);</pre>
<p>
<a name="indexterm-218"></a>The <var>pshared</var> lock
attribute has one of the following values:</p>
<dl>
<br>
<p>
<tt>PTHREAD_PROCESS_SHARED</tt>
</p>

<b>Description: </b>
<p>Permits a read-write lock to be operated
on by any thread that has access to the memory where the read-write lock is
allocated. Operation on the read-write lock is permitted even if the lock
is allocated in memory that is shared by multiple processes.</p>


</dl><dl>
<br>
<p>
<tt>PTHREAD_PROCESS_PRIVATE</tt>
</p>

<b>Description: </b>
<p>The read-write lock is only operated upon
by threads created within the same process as the thread that initialized
the read-write lock. If threads of differing processes attempt to operate
on such a read-write lock, the behavior is undefined. The default value of
the process-shared attribute is  <tt>PTHREAD_PROCESS_PRIVATE</tt>.</p>


</dl><a name="6mba5vq6i"></a><h3 class="sol">
<tt>pthread_rwlockattr_setpshared</tt> Return
Values</h3>
<p>
<a name="indexterm-219"></a>If successful, <kbd><b>pthread_rwlockattr_setpshared()</b></kbd>  returns zero. Otherwise, an error number is returned to indicate
the error.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>attr</var> or
 <var>pshared</var> is invalid.</p>


</dl><a name="6mba5vq6k"></a><h2 class="sol">Getting a Read-Write Lock Attribute</h2>
<p>
<a name="indexterm-220"></a><a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-rwlockattr-getpshared-3c/index.html">pthread_rwlockattr_getpshared(3C)</a> gets the
process-shared read-write lock attribute.</p>
<a name="6mba5vq6m"></a><h3 class="sol">
<tt>pthread_rwlockattr_getpshared</tt> Syntax</h3>
<a name="indexterm-221"></a><a name=""></a><pre>#include &lt;pthread.h&gt; 
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict <var>attr</var>, 
          int *restrict <var>pshared</var>);</pre>
<p>
<kbd><b>pthread_rwlockattr_getpshared()</b></kbd> obtains the value
of the process-shared attribute from the initialized attributes object referenced
by  <var>attr</var>.</p>
<a name="6mba5vq6o"></a><h3 class="sol">
<tt>pthread_rwlockattr_getpshared</tt> Return
Values</h3>
<p>
<a name="indexterm-222"></a>If successful, <kbd><b>pthread_rwlockattr_getpshared()</b></kbd>  returns zero. Otherwise, an error number is returned to indicate
the error.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>attr</var> or
 <var>pshared</var> is invalid.</p>


</dl><a name="6mba5vq6q"></a><h1 class="sol">Using Read-Write Locks</h1>
<p>After the attributes for a read-write lock are configured, you initialize
the read-write lock. The following functions are used to initialize or destroy,
lock or unlock, or try to lock a read-write lock. The following table lists
the functions discussed in this section that manipulate read-write locks.</p>
<a name="sync-tbl-62"></a>Table 4–8  Routines that Manipulate Read-Write
Locks<table width="100%" cellpadding="10" cellspacing="0" border="2">
<caption>
<b></b>
</caption>
<thead>
<tr>
<th scope="col" align="left" valign="top">
<p>Operation&nbsp;</p>

</th><th scope="col" align="left" valign="top">
<p>Related Function Description&nbsp;</p>

</th>
</tr>

</thead>
<tbody>
<tr>
<td align="left" valign="top">
<p>Initialize a read-write lock&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-51/index.html"><tt>pthread_rwlock_init</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Read lock on read-write lock&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-65/index.html"><tt>pthread_rwlock_rdlock</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Read lock with a nonblocking read-write lock&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-67/index.html"><tt>pthread_rwlock_tryrdlock</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Write lock on read-write lock&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-71/index.html"><tt>pthread_rwlock_wrlock</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Write lock with a nonblocking read-write lock&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-72/index.html"><tt>pthread_rwlock_trywrlock</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Unlock a read-write lock&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-74/index.html"><tt>pthread_rwlock_unlock</tt> Syntax</a>
</p>

</td>
</tr>

<tr>
<td align="left" valign="top">
<p>Destroy a read-write lock&nbsp;</p>

</td><td align="left" valign="top">
<p>
<a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/sync-63/index.html"><tt>pthread_rwlock_destroy</tt> Syntax</a>
</p>

</td>
</tr>

</tbody>
</table>
<p> 
</p><a name="6mba5vq6s"></a><h2 class="sol">Initializing a Read-Write Lock</h2>
<p>
<a name="indexterm-223"></a>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-rwlock-init-3c/index.html">pthread_rwlock_init(3C)</a> to initialize
the read-write lock referenced by <var>rwlock</var> with the
attributes referenced by <var>attr</var>.</p>
<a name="6mba5vq6u"></a><h3 class="sol">
<tt>pthread_rwlock_init</tt> Syntax</h3>
<a name="indexterm-224"></a><a name=""></a><pre>#include &lt;pthread.h&gt;

int pthread_rwlock_init(pthread_rwlock_t *restrict <var>rwlock</var>, 
          const pthread_rwlockattr_t *restrict <var>attr</var>);

pthread_rwlock_t  <var>rwlock</var> = PTHREAD_RWLOCK_INITIALIZER;</pre>
<p>If <var>attr</var> is <tt>NULL</tt>, the default
read-write lock attributes are used. The effect is the same as passing the
address of a default read-write lock attributes object. After the lock is
initialized, the lock can be used any number of times without being re-initialized.
On successful initialization, the state of the read-write lock becomes initialized
and unlocked. Results are undefined if <kbd><b>pthread_rwlock_init()</b></kbd> is
called specifying an already initialized read-write lock. Results are undefined
if a read-write lock is used without first being initialized. </p>
<p>In cases where default read-write lock attributes are appropriate, the
macro  <tt>PTHREAD_RWLOCK_INITIALIZER</tt> can initialize read-write
locks that are statically allocated. The effect is equivalent to dynamic initialization
by a call to  <kbd><b>pthread_rwlock_init()</b></kbd> with the parameter <var>attr</var> specified as <tt>NULL</tt>, except that no error
checks are performed.</p>
<a name="6mba5vq70"></a><h3 class="sol">
<tt>pthread_rwlock_init</tt> Return
Values</h3>
<p>
<a name="indexterm-225"></a>If successful, <kbd><b>pthread_rwlock_init()</b></kbd>  returns zero. Otherwise, an error number is returned to indicate
the error.</p>
<p>If <kbd><b>pthread_rwlock_init()</b></kbd> fails, <var>rwlock</var> is
not initialized and the contents of <var>rwlock</var> are
undefined.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>attr</var> or
 <var>rwlock</var> is invalid.</p>


</dl><a name="6mba5vq72"></a><h2 class="sol">Acquiring the Read Lock on Read-Write Lock</h2>
<p>
<a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-rwlock-rdlock-3c/index.html">pthread_rwlock_rdlock(3C)</a> applies a read lock to the read-write lock referenced
by <var>rwlock</var>.</p>
<a name="6mba5vq74"></a><h3 class="sol">
<tt>pthread_rwlock_rdlock</tt> Syntax</h3>
<a name="indexterm-226"></a><a name=""></a><pre>#include &lt;pthread.h&gt;

int  pthread_rwlock_rdlock(pthread_rwlock_t <var>*rwlock</var> );</pre>
<p>
<a name="indexterm-227"></a>The calling thread acquires the read lock if a
writer does not hold the lock and no writers are blocked on the lock. Whether
the calling thread acquires the lock when a writer does not hold the lock
and writers are waiting for the lock is unspecified. If a writer holds the
lock, the calling thread does not acquire the read lock. If the read lock
is not acquired, the calling thread blocks. The thread does not return from
the <kbd><b>pthread_rwlock_rdlock()</b></kbd> until the thread can acquire
the lock. Results are undefined if the calling thread holds a write lock on <var>rwlock</var> at the time the call is made.</p>
<p>Implementations are allowed to favor writers over readers to avoid writer
starvation. The Solaris implementation favors writers over readers.</p>
<p>A thread can hold multiple concurrent read locks on <var>rwlock</var> The
thread can successfully call <kbd><b>pthread_rwlock_rdlock()</b></kbd>  <b>n</b> times. The thread must call <kbd><b>pthread_rwlock_unlock()</b></kbd>  <b>n</b> times to perform matching unlocks.</p>
<p>Results are undefined if <kbd><b>pthread_rwlock_rdlock()</b></kbd> is
called with an uninitialized read-write lock.</p>
<p>A thread signal handler processes a signal delivered to a thread waiting
for a read-write lock. On return from the signal handler, the thread resumes
waiting for the read-write lock for reading as if the thread was not interrupted.</p>
<a name="6mba5vq76"></a><h3 class="sol">
<tt>pthread_rwlock_rdlock</tt> Return
Values</h3>
<p>
<a name="indexterm-228"></a>If successful, <kbd><b>pthread_rwlock_rdlock()</b></kbd>  returns zero. Otherwise, an error number is returned to indicate
the error.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>attr</var> or
 <var>rwlock</var> is invalid.</p>


</dl><a name="6mba5vq78"></a><h2 class="sol">Acquiring a Read Lock on a Read-Write Lock Before
a Specified Absolute Time</h2>
<p>The <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-rwlock-timedrdlock-3c/index.html">pthread_rwlock_timedrdlock(3C)</a> function applies a read lock to the read-write lock
referenced by <var>rwlock</var> as in the <kbd><b>pthread_rwlock_rdlock()</b></kbd> function.</p>
<a name="6mba5vq7a"></a><h3 class="sol">
<tt>pthread_rwlock_timedrdlock</tt> Syntax</h3>
<a name="indexterm-229"></a><a name=""></a><pre>#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

int  pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict <var>rwlock</var>,
          const struct timespec *restrict <var>abs_timeout</var>);</pre>
<p>If the lock cannot be acquired without waiting for other threads to
unlock the lock, this wait will be terminated when the specified timeout expires.
The timeout expires when the absolute time specified by <var>abs_timeout</var> passes,
as measured by the <tt>CLOCK_REALTIME</tt> clock (that is, when
the value of that clock equals or exceeds <var>abs_timeout</var>),
or if the absolute time specified by <var>abs_timeout</var> has
already been passed at the time of the call.</p>
<p>The resolution of the timeout is the resolution of the  <tt>CLOCK_REALTIME</tt> clock. The <tt>timespec</tt> data type is defined in
 the <tt>&lt;time.h&gt;</tt> header. Under no circumstances does the
function fail with a timeout if the lock can be acquired immediately. The
validity of the timeout parameter need not be checked if the lock can be immediately
acquired.</p>
<p>If a signal that causes a signal handler to be executed is  delivered
to a thread blocked on a read-write lock with a  call to <kbd><b>pthread_rwlock_timedrdlock()</b></kbd>, upon return from the signal handler the thread resumes waiting
for the lock as if  it was not interrupted.</p>
<p>The calling thread might deadlock if at the time the call is  made it
holds a write lock on <var>rwlock</var>. </p>
<p>The <kbd><b>pthread_rwlock_reltimedrdlock_np()</b></kbd> function is
identical to the <kbd><b>pthread_rwlock_timedrdlock()</b></kbd> function,
except that the timeout is specified as a relative time interval.</p>
<a name="6mba5vq7c"></a><h3 class="sol">
<tt>pthread_rwlock_timedrdlock</tt> Return
Values</h3>
<a name="indexterm-230"></a><p>If successful, returns 0 if the lock for writing on the read-write lock
object referenced by rwlock is acquired. Otherwise, an error number is returned
to indicate the error.</p>
<dl>
<br>
<p>
<tt><samp>ETIMEDOUT</samp></tt>
</p>

<b>Description: </b>
<p>The lock could not be acquired before
the specified timeout expired.</p>


</dl><dl>
<br>
<p>
<tt><samp>EAGAIN</samp></tt>
</p>

<b>Description: </b>
<p>The read lock could not be acquired because
the maximum number of read locks for lock would be exceeded.</p>


</dl><dl>
<br>
<p>
<tt><samp>EDEADLK</samp></tt>
</p>

<b>Description: </b>
<p>The calling thread already holds the <var>rwlock</var>.</p>


</dl><dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>rwlock</var> does
not refer to an initialized read-write lock object, or the timeout nanosecond
value is less than zero or greater than or equal to 1,000 million.</p>


</dl><a name="6mba5vq7e"></a><h2 class="sol">Acquiring a Non-Blocking Read Lock on a Read-Write
Lock</h2>
<p>
<a name="indexterm-231"></a><a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-rwlock-tryrdlock-3c/index.html">pthread_rwlock_tryrdlock(3C)</a> applies a
read lock as in <kbd><b>pthread_rwlock_rdlock()</b></kbd> with the exception
that the function fails if any thread holds a write lock on <var>rwlock</var> or
writers are blocked on <var>rwlock</var>.</p>
<a name="6mba5vq7g"></a><h3 class="sol">
<tt>pthread_rwlock_tryrdlock</tt> Syntax</h3>
<a name="indexterm-232"></a><a name=""></a><pre>#include &lt;pthread.h&gt;

int pthread_rwlock_tryrdlock(pthread_rwlock_t *<var>rwlock</var>);</pre>
<a name="6mba5vq7i"></a><h3 class="sol">
<tt>pthread_rwlock_tryrdlock</tt> Return
Values</h3>
<p>
<a name="indexterm-233"></a><kbd><b>pthread_rwlock_tryrdlock()</b></kbd> returns zero if the lock for reading on the read-write lock object
referenced by <var>rwlock</var> is acquired. If the lock is
not acquired, an error number is returned to indicate the error.</p>
<dl>
<br>
<p>
<tt><samp>EBUSY</samp></tt>
</p>

<b>Description: </b>
<p>The read-write lock could not be acquired
for reading because a writer holds the lock or was blocked on it.</p>


</dl><a name="6mba5vq7k"></a><h2 class="sol">Acquiring the Write Lock on a Read-Write Lock</h2>
<p>
<a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-rwlock-wrlock-3c/index.html">pthread_rwlock_wrlock(3C)</a> applies a write lock to the read-write lock referenced
by <var>rwlock</var>.</p>
<a name="6mba5vq7m"></a><h3 class="sol">
<tt>pthread_rwlock_wrlock</tt> Syntax</h3>
<a name="indexterm-234"></a><a name=""></a><pre>#include &lt;pthread.h&gt;

int  pthread_rwlock_wrlock(pthread_rwlock_t <var>*rwlock</var> );</pre>
<p>
<a name="indexterm-235"></a>The calling thread acquires the write lock if
no other reader thread or writer thread holds the read-write lock <var>rwlock</var>. Otherwise, the thread blocks. The thread does not return from
the <kbd><b>pthread_rwlock_wrlock()</b></kbd>  call until the thread can
acquire the lock. Results are undefined if the calling thread holds the read-write
lock, either a read lock or write lock, at the time the call is made.</p>
<p>Implementations are allowed to favor writers over readers to avoid writer
starvation. The Solaris implementation favors writers over readers.</p>
<p>Results are undefined if <kbd><b>pthread_rwlock_wrlock()</b></kbd> is
called with an uninitialized read-write lock.</p>
<p>The thread signal handler processes a signal delivered to a thread waiting
for a read-write lock for writing. Upon return from the signal handler, the
thread resumes waiting for the read-write lock for writing as if the thread
was not interrupted.</p>
<a name="6mba5vq7o"></a><h3 class="sol">
<tt>pthread_rwlock_wrlock</tt> Return
Values</h3>
<p>
<a name="indexterm-236"></a><kbd><b>pthread_rwlock_rwlock()</b></kbd> returns
zero if the lock for writing on the read-write lock object referenced by  <var>rwlock</var> is acquired. If the lock is not acquired, an error number
is returned to indicate the error.</p>
<a name="6mba5vq7q"></a><h2 class="sol">Acquiring a Non-blocking Write Lock on a Read-Write
Lock</h2>
<p>
<a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-rwlock-trywrlock-3c/index.html">pthread_rwlock_trywrlock(3C)</a> applies a write lock like <kbd><b>pthread_rwlock_wrlock()</b></kbd>, with the exception that the function fails if any thread currently
holds <var>rwlock</var>, for reading or writing. </p>
<a name="6mba5vq7s"></a><h3 class="sol">
<tt>pthread_rwlock_trywrlock</tt> Syntax</h3>
<a name="indexterm-237"></a><a name=""></a><pre>#include &lt;pthread.h&gt;

int pthread_rwlock_trywrlock(pthread_rwlock_t  <var>*rwlock</var>);</pre>
<p>
<a name="indexterm-238"></a>Results are undefined if <kbd><b>pthread_rwlock_trywrlock()</b></kbd>  is called with an uninitialized read-write lock.</p>
<a name="6mba5vq7u"></a><h3 class="sol">
<tt>pthread_rwlock_trywrlock</tt> Return
Values</h3>
<p>
<a name="indexterm-239"></a>If successful, <kbd><b>pthread_rwlock_trywrlock()</b></kbd>  returns zero if the lock for writing on the read-write lock object
referenced by <var>rwlock</var> is acquired. Otherwise, an
error number is returned to indicate the error.</p>
<dl>
<br>
<p>
<tt><samp>EBUSY</samp></tt>
</p>

<b>Description: </b>
<p>The read-write lock could not be acquired
for writing because the read-write lock is already locked for reading or writing.</p>


</dl><a name="6mba5vq80"></a><h2 class="sol">Acquiring a Write Lock on a Read-Write Lock Before
a Specified Absolute Time</h2>
<p>The <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-rwlock-timedwrlock-3c/index.html">pthread_rwlock_timedwrlock(3C)</a> function applies a write lock to the read-write lock
referenced by <var>rwlock</var> as in the <kbd><b>pthread_rwlock_wrlock()</b></kbd> function, but attempts to apply the lock only until a specified
absolute time.</p>
<a name="6mba5vq82"></a><h3 class="sol">
<tt>pthread_rwlock_timedwrlock</tt> Syntax</h3>
<a name=""></a><pre>#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

int  pthread_rwlock_timedwrlock(pthread_rwlock_t   *restrict <var>rwlock</var>, 
     const struct timespec *restrict <var>abs_timeout</var>);</pre>
<p>
<a name="indexterm-240"></a>The calling thread acquires the write lock if no other reader
thread or writer thread holds the read-write lock <var>rwlock</var>.
If the lock cannot be acquired without waiting for other threads to unlock
the lock, this wait will be terminated when the specified timeout expires.
The timeout expires when the absolute time specified by <var>abs_timeout</var>passes,
as measured by the <tt>CLOCK_REALTIME</tt> clock (that is, when
the value of that clock equals or exceeds <var>abs_timeout</var>)
or if the absolute time specified by <var>abs_timeout</var> has
already been passed at the time of the call. The <kbd><b>pthread_rwlock_reltimedwrlock_np()</b></kbd> function is identical to the <kbd><b>pthread_rwlock_timedwrlock()</b></kbd> function,
except that the timeout is specified as a relative time interval.</p>
<a name="6mba5vq84"></a><h3 class="sol">
<tt>pthread_rwlock_timedwrlock</tt> Returns</h3>
<p>If successful, returns 0 if the lock for writing on the read-write lock
object referenced by rwlock  is  acquired. Otherwise, an error number is returned
to indicate the error.</p>
<dl>
<br>
<p>
<tt><samp>ETIMEDOUT</samp></tt>
</p>

<b>Description: </b>
<p>The lock could not be  acquired  before
the specified timeout expired.</p>


</dl><dl>
<br>
<p>
<tt><samp>EDEADLK</samp></tt>
</p>

<b>Description: </b>
<p>The calling thread already holds the <var>rwlock</var>.</p>


</dl><dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>rwlock</var> does
not refer to an initialized read-write lock object, or the timeout nanosecond
value is less than zero or greater than or equal to 1,000 million.</p>


</dl><a name="6mba5vq86"></a><h2 class="sol">Unlocking a Read-Write Lock</h2>
<p>
<a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-rwlock-unlock-3c/index.html">pthread_rwlock_unlock(3C)</a> releases a lock held on the read-write lock object
referenced by <var>rwlock</var>.</p>
<a name="6mba5vq88"></a><h3 class="sol">
<tt>pthread_rwlock_unlock</tt> Syntax</h3>
<a name="indexterm-241"></a><a name=""></a><pre>#include &lt;pthread.h&gt;

int pthread_rwlock_unlock (pthread_rwlock_t  *<var>rwlock</var>);</pre>
<p>
<a name="indexterm-242"></a>Results are undefined if the read-write lock <var>rwlock</var>  is not held by the calling thread.</p>
<p>If <kbd><b>pthread_rwlock_unlock()</b></kbd> is called to release a
read lock from the read-write lock object, and other read locks are currently
held on this lock object, the object remains in the read locked state. If <kbd><b>pthread_rwlock_unlock()</b></kbd>  releases the calling thread's last read
lock on this read-write lock object, the calling thread is no longer an owner
of the object. If <kbd><b>pthread_rwlock_unlock()</b></kbd>  releases the
last read lock for this read-write lock object, the read-write lock object
is put in the unlocked state with no owners.</p>
<p>If <kbd><b>pthread_rwlock_unlock()</b></kbd> is called to release a
write lock for this read-write lock object, the lock object is put in the
unlocked state with no owners.</p>
<p>If <kbd><b>pthread_rwlock_unlock()</b></kbd> unlocks the read-write
lock object and multiple threads are waiting to acquire the lock object for
writing, the scheduling policy determines which thread acquires the object
for writing. If multiple threads are waiting to acquire the read-write lock
object for reading, the scheduling policy determines the order the waiting
threads acquire the object for reading. If multiple threads are blocked on <var>rwlock</var> for both read locks and write locks, whether the readers
or the writer acquire the lock first is unspecified.</p>
<p>Results are undefined if <kbd><b>pthread_rwlock_unlock()</b></kbd> is
called with an uninitialized read-write lock.</p>
<a name="6mba5vq8a"></a><h3 class="sol">
<tt>pthread_rwlock_unlock</tt> Return
Values</h3>
<p>
<a name="indexterm-243"></a>If successful, <kbd><b>pthread_rwlock_unlock()</b></kbd>  returns zero. Otherwise, an error number is returned to indicate
the error.</p>
<a name="6mba5vq8c"></a><h2 class="sol">Destroying a Read-Write Lock</h2>
<p>
<a name="indexterm-244"></a><a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-rwlock-destroy-3c/index.html">pthread_rwlock_destroy(3C)</a> destroys the read-write lock object referenced by <var>rwlock</var> and releases any resources used by the lock.</p>
<a name="6mba5vq8e"></a><h3 class="sol">
<tt>pthread_rwlock_destroy</tt> Syntax</h3>
<a name="indexterm-245"></a><a name=""></a><pre>#include &lt;pthread.h&gt;

int pthread_rwlock_destroy(pthread_rwlock_t **<var>rwlock</var>);</pre>
<p>The effect of subsequent use of the lock is undefined until the lock
is re-initialized by another call to <kbd><b>pthread_rwlock_init()</b></kbd>.
An implementation can cause <kbd><b>pthread_rwlock_destroy()</b></kbd> to
set the object referenced by  <var>rwlock</var> to an invalid
value. Results are undefined if <kbd><b>pthread_rwlock_destroy()</b></kbd> 
is called when any thread holds <var>rwlock</var>. Attempting
to destroy an uninitialized read-write lock results in undefined behavior.
A destroyed read-write lock object can be re-initialized using <kbd><b>pthread_rwlock_init()</b></kbd>. The results of otherwise referencing the read-write lock object
after the lock object has been destroyed are undefined.</p>
<a name="6mba5vq8g"></a><h3 class="sol">
<tt>pthread_rwlock_destroy</tt> Return
Values</h3>
<p>
<a name="indexterm-246"></a>If successful, <kbd><b>pthread_rwlock_destroy()</b></kbd>  returns zero. Otherwise, an error number is returned to indicate
the error.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>attr</var> or
 <var>rwlock</var> is invalid.</p>


</dl><a name="6mba5vq8i"></a><h1 class="sol">Using Barrier Synchronization</h1>
<a name="indexterm-247"></a><p>In cases where you must wait for a number of tasks to be completed before
an overall task can proceed, <b>barrier synchronization</b> can
be used. POSIX threads specifies a synchronization object called
a <b>barrier</b>, along with barrier functions. The functions
create the barrier, specifying the number of threads that are synchronizing
on the barrier, and set up threads to perform tasks and wait at the barrier
until all the threads reach the barrier. When the last thread arrives at the
barrier, all the threads resume execution.</p>
<p>See <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/guide-41220/index.html">Parallelizing a Loop on a Shared-Memory Parallel Computer</a> for more about barrier synchronization.</p>
<a name="6mba5vq8k"></a><h2 class="sol">Initializing a Synchronization Barrier</h2>
<p>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-barrier-init-3c/index.html">pthread_barrier_init(3C)</a> to allocate resources for a barrier and initialize
its attributes.</p>
<a name="6mba5vq8m"></a><h3 class="sol">
<kbd><b>pthread_barrier_init()</b></kbd> Syntax</h3>
<a name="indexterm-248"></a><a name=""></a><pre>int pthread_barrier_init(pthread_barrier_t  *<var>barrier</var>, 
          const pthread_barrierattr_t *restrict <var>attr</var>, 
          unsigned <var>count</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt; 
pthread_barrier_t <var>barrier</var>; 
pthread_barrierattr_t <var>attr</var>;
unsigned <var>count</var>;
int <var>ret</var>; 
<var>ret</var> = pthread_barrier_init(&amp;<var>barrier</var>, &amp;<var>attr</var>, <var>count</var>);</pre>
<p>The <kbd><b>pthread_barrier_init()</b></kbd> function allocates any
resources required to use the barrier referenced by <var>barrier</var> and
initializes the barrier with attributes referenced by <var>attr</var>.
If <var>attr</var> is NULL, the default barrier attributes
are used; the effect is the same as passing the address of a default barrier
attributes object. The <var>count</var> argument specifies
the number of threads that must  call <kbd><b>pthread_barrier_wait()</b></kbd> before
any of them successfully return from the call. The value specified by <var>count</var> must be greater than 0. </p>
<a name="6mba5vq8o"></a><h3 class="sol">
<kbd><b>pthread_barrier_init()</b></kbd> Return
Values</h3>
<a name="indexterm-249"></a><p>
<kbd><b>pthread_barrier_init()</b></kbd> returns zero after completing
successfully. Any other return value indicates that an error occurred. If
the following condition occurs, the function fails and returns the corresponding
value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>count</var> is
equal to 0, or the value specified by <var>attr</var> is invalid</p>


</dl><dl>
<br>
<p>
<tt><samp>EAGAIN</samp></tt>
</p>

<b>Description: </b>
<p>The system lacks the necessary resources
to initialize another barrier.</p>


</dl><dl>
<br>
<p>
<tt><samp>ENOMEM</samp></tt>
</p>

<b>Description: </b>
<p>Insufficient memory exists to initialize
the barrier.</p>


</dl><dl>
<br>
<p>
<tt><samp>EBUSY</samp></tt>
</p>

<b>Description: </b>
<p>There was an attempt to destroy a barrier
while it is in use (for  example, while being used in a <kbd><b>pthread_barrier_wait()</b></kbd> call) by another thread. </p>


</dl><a name="6mba5vq8q"></a><h2 class="sol">Waiting for Threads to Synchronize at a Barrier</h2>
<p>Use <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-barrier-wait-3c/index.html">pthread_barrier_wait(3C)</a> to synchronize threads  at a specified barrier. The
calling thread blocks until the required number of threads have called <kbd><b>pthread_barrier_wait()</b></kbd> specifying the barrier. The number of threads
is specified in the <kbd><b>pthread_barrier_init()</b></kbd> function.</p>
<p>When the required number of threads have called <kbd><b>pthread_barrier_wait()</b></kbd> specifying the barrier, the constant <tt>PTHREAD_BARRIER_SERIAL_THREAD</tt> is returned to one unspecified thread and 0 is returned to each
of the remaining threads. The barrier is then reset to the state it had as
a result of the most recent <kbd><b>pthread_barrier_init()</b></kbd> function
that referenced it.</p>
<a name="6mba5vq8s"></a><h3 class="sol">
<kbd><b>pthread_barrier_wait()</b></kbd> Syntax</h3>
<a name="indexterm-250"></a><a name=""></a><pre>int pthread_barrier_wait(pthread_barrier_t  *<var>barrier</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt; 
pthread_barrier_t <var>barrier</var>; 
int <var>ret</var>; 
<var>ret</var> = pthread_barrier_wait(&amp;<var>barrier</var>);</pre>
<a name="6mba5vq8u"></a><h3 class="sol">
<kbd><b>pthread_barrier_wait()</b></kbd> Return
Values</h3>
<a name="indexterm-251"></a><p>When <kbd><b>pthread_barrier_wait()</b></kbd> completes successfully,
the function returns <tt>PTHREAD_BARRIER_SERIAL_THREAD</tt>, which
is defined in <kbd>pthread.h</kbd>, for one arbitrary thread synchronized
at the barrier. The function returns zero for each of the other threads. Otherwise
an error code is returned.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>The value specified by <var>barrier</var> does
not refer to an initialized barrier object.</p>


</dl><a name="6mba5vq90"></a><h2 class="sol">Destroying a Synchronization Barrier</h2>
<p>When a barrier is no longer needed, it should be destroyed. Use the <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-barrier-destroy-3c/index.html">pthread_barrier_destroy(3C)</a> function to destroy the barrier referenced by <var>barrier</var> and release any resources used by the barrier.</p>
<a name="6mba5vq92"></a><h3 class="sol">
<tt>pthread_barrier_destroy</tt> Syntax</h3>
<a name="gfwbo"></a><a name=""></a><pre>int pthread_barrier_destroy(pthread_barrier_t *<var>barrier</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt; 
pthread_barrier_t <var>barrier</var>; 
int <var>ret</var>; 
<var>ret</var> = pthread_barrier_destroy(&amp;<var>barrier</var>);</pre>
<a name="6mba5vq94"></a><h3 class="sol">
<tt>pthread_barrier_destroy</tt> Return
Values</h3>
<p>
<a name="indexterm-252"></a><kbd><b>pthread_barrier_destroy()</b></kbd> returns zero after completing successfully. Any other return value
indicates that an error occurred. If the following condition occurs, the function
fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>Indicates that the value of <var>barrier</var> was not valid.</p>


</dl><dl>
<br>
<p>
<tt><samp>EBUSY</samp></tt>
</p>

<b>Description: </b>
<p>An attempt was made to destroy a barrier
while it is in use (for example, while being used in a <kbd><b>pthread_barrier_wait()</b></kbd> by another thread.</p>


</dl><a name="6mba5vq96"></a><h2 class="sol">Initializing a Barrier Attributes Object</h2>
<p>The <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-barrierattr-init-3c/index.html">pthread_barrierattr_init(3C)</a> function initializes a barrier attributes object <var>attr</var> with the default values for the attributes defined for
the object by the implementation.  Currently, only the process-shared attribute
is provided, and the <kbd><b>pthread_barrierattr_getpshared()</b></kbd> and <kbd><b>pthread_barrierattr_setpshared()</b></kbd> functions are used to get and set
the attribute.</p>
<p>After a barrier attributes object has been used to initialize one or
more barriers, any function affecting the attributes object (including destruction)
does not affect any previously initialized barrier.</p>
<a name="6mba5vq98"></a><h3 class="sol">
<kbd><b>pthread_barrierattr_init()</b></kbd> Syntax</h3>
<a name="indexterm-253"></a><a name=""></a><pre>int pthread_barrierattr_init(pthread_barrierattr_t *<var>attr</var>);</pre>
<a name=""></a><pre>#include &lt;pthread.h&gt; 
pthread_barrierattr_t <var>attr</var>; 
int <var>ret</var>; 
<var>ret</var> = pthread_barrierattr_init(&amp;<var>attr</var>);</pre>
<a name="6mba5vq9a"></a><h3 class="sol">
<kbd><b>pthread_barrierattr_init()</b></kbd> Return
Values</h3>
<a name="indexterm-254"></a><p>
<kbd><b>pthread_barrierattr_init()</b></kbd> returns zero after completing
successfully. Any other return value indicates that an error occurred. If
the following condition occurs, the function fails and returns the corresponding
value.</p>
<dl>
<br>
<p>
<tt><samp>ENOMEM</samp></tt>
</p>

<b>Description: </b>
<p>Insufficient memory exists to initialize
the barrier attributes object.</p>


</dl><a name="6mba5vq9c"></a><h2 class="sol">Setting a Barrier Process-Shared Attribute</h2>
<p>The <kbd><b>pthread_barrierattr_setpshared()</b></kbd> function sets
the process-shared attribute in an initialized attributes object  referenced
by <var>attr</var>. The process-shared attribute can have
the following values:</p>
<a name=""></a><dl>
<dt>
<tt>PTHREAD_PROCESS_PRIVATE</tt>
</dt>
<dd>
<p>The barrier can only be operated upon by threads created within
the same process as the thread that initialized the barrier. This is the default
value of the process-shared attribute.</p>

</dd>
<dt>
<tt>PTHREAD_PROCESS_SHARED</tt>
</dt>
<dd>
<p>The barrier can be operated upon by any thread that has access
to the memory where the barrier is allocated.</p>

</dd>
</dl>
<a name="6mba5vq9e"></a><h3 class="sol">
<kbd><b>pthread_barrierattr_setpshared()</b></kbd> Syntax</h3>
<a name=""></a><pre>int pthread_barrierattr_setpshared(pthread_barrierattr_t *<var>attr</var>, int <var>pshared</var>);</pre>
<a name="6mba5vq9g"></a><h3 class="sol">
<kbd><b>pthread_barrierattr_setpshared()</b></kbd> Return
Values</h3>
<p>
<a name="indexterm-255"></a><kbd><b>pthread_barrierattr_setpshared()</b></kbd> returns zero after completing successfully. Any other return value
indicates that an error occurred. If the following condition occurs, the function
fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>Indicates that the value of <var>attr</var> was not valid, or the new value specified for the <var>pshared</var> is not valid.</p>


</dl><a name="6mba5vq9i"></a><h2 class="sol">Getting a Barrier Process-Shared Attribute</h2>
<p>The <a href="http://docs.oracle.com/docs/cd/E19253-01/816-5168/pthread-barrierattr-getpshared-3c/index.html">pthread_barrierattr_getpshared(3C)</a> function
obtains the value of the process-shared attribute from the attributes object
referenced by <var>attr</var>. The value is set by the <kbd><b>pthread_barrierattr_setpshared()</b></kbd> function.</p>
<a name="6mba5vq9k"></a><h3 class="sol">
<kbd><b>pthread_barrierattr_getpshared()</b></kbd> Syntax</h3>
<a name=""></a><pre>int pthread_barrierattr_getpshared(const pthread_barrierattr_t *restrict <var>attr</var>, 
          int *restrict <var>pshared</var>);</pre>
<a name="6mba5vq9m"></a><h3 class="sol">
<kbd><b>pthread_barrierattr_getpshared()</b></kbd> Return
Values</h3>
<p>
<a name="indexterm-256"></a><kbd><b>pthread_barrierattr_getpshared()</b></kbd> returns zero after completing successfully, and stores the value
of the process-shared attribute of <var>attr</var> into the
object referenced by the <var>pshared</var> parameter. Any
other return value indicates that an error occurred. If the following condition
occurs, the function fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>Indicates that the value of <var>attr</var> was not valid.</p>


</dl><a name="6mba5vq9o"></a><h2 class="sol">Destroying a Barrier Attributes Object</h2>
<p>The <kbd><b>pthread_barrierattr_destroy()</b></kbd> function destroys
a barrier attributes object. A destroyed <var>attr</var> attributes
object can be reinitialized using <kbd><b>pthread_barrierattr_init()</b></kbd>. </p>
<p>After a barrier attributes object has been used to initialize one or
more barriers, destroying the object does not affect any previously initialized
barrier.</p>
<a name="6mba5vq9q"></a><h3 class="sol">
<kbd><b>pthread_barrierattr_destroy()</b></kbd> Syntax</h3>
<a name="indexterm-257"></a><a name=""></a><pre>#include &lt;pthread.h&gt;

int  pthread_barrierattr_destroy(pthread_barrierattr_t *<var>attr</var>);</pre>
<a name="6mba5vq9s"></a><h3 class="sol">
<kbd><b>pthread_barrierattr_destroy()</b></kbd> Return
Values</h3>
<p>
<a name="indexterm-258"></a><kbd><b>pthread_barrierattr_destroy()</b></kbd> returns zero after completing successfully. Any other return value
indicates that an error occurred. If the following condition occurs, the function
fails and returns the corresponding value.</p>
<dl>
<br>
<p>
<tt><samp>EINVAL</samp></tt>
</p>

<b>Description: </b>
<p>Indicates that the value of <var>attr</var> was not valid.</p>


</dl><a name="6mba5vq9u"></a><h1 class="sol">Synchronization Across Process Boundaries</h1>
<p>Each of the synchronization primitives can be used across process boundaries.
The primitives are set up by ensuring that the synchronization variable is
located in a shared memory segment and by calling the appropriate <kbd><b>init()</b></kbd> routine.
The primitive must have been initialized with its shared attribute set to
interprocess.</p>
<a name="6mba5vqa0"></a><h2 class="sol">Producer and Consumer Problem Example</h2>
<p>
<a name="sync-ix434"></a><a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vqa0/index.html#sync-37018">Example 4–17</a> shows
the producer and consumer problem with the producer and consumer in separate
processes. The main routine maps zero-filled memory shared with its child
process into its address space.</p>
<p>A child process is created to run the consumer. The parent runs the
producer.</p>
<p>This example also shows the drivers for the producer and consumer. The
 <kbd><b>producer_driver()</b></kbd> reads characters from <tt>stdin</tt> and
calls  <kbd><b>producer()</b></kbd>. The <kbd><b>consumer_driver()</b></kbd> gets
characters by calling  <kbd><b>consumer()</b></kbd> and writes them to <tt>stdout</tt>.</p>
<p>The data structure for <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vqa0/index.html#sync-37018">Example 4–17</a> is the same as the structure used for the condition variables example,
shown in <a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/6mba5vq14/index.html#sync-78558">Example 4–4</a>. Two
semaphores represent the number of full and empty buffers. The semaphores
ensure that producers wait for empty buffers and that consumers wait until
the buffers are full.</p>
<a name="sync-37018"></a><hr><h5 class="sol">Example 4–17  Synchronization Across Process Boundaries</h5><br><a name=""></a><pre>main() {
    int zfd;
    buffer_t *buffer;
    pthread_mutexattr_t mattr;
    pthread_condattr_t cvattr_less, cvattr_more;

    zfd = open("/dev/zero", O_RDWR);
    buffer = (buffer_t *)mmap(NULL, sizeof(buffer_t),
        PROT_READ|PROT_WRITE, MAP_SHARED, zfd, 0);
    buffer-&gt;occupied = buffer-&gt;nextin = buffer-&gt;nextout = 0;

    pthread_mutex_attr_init(&amp;mattr);
    pthread_mutexattr_setpshared(&amp;mattr,
        PTHREAD_PROCESS_SHARED);

    pthread_mutex_init(&amp;buffer-&gt;lock, &amp;mattr);
    pthread_condattr_init(&amp;cvattr_less);
    pthread_condattr_setpshared(&amp;cvattr_less, PTHREAD_PROCESS_SHARED);
    pthread_cond_init(&amp;buffer-&gt;less, &amp;cvattr_less);
    pthread_condattr_init(&amp;cvattr_more);
    pthread_condattr_setpshared(&amp;cvattr_more,   
        PTHREAD_PROCESS_SHARED);
    pthread_cond_init(&amp;buffer-&gt;more, &amp;cvattr_more);

    if (fork() == 0)
        consumer_driver(buffer);
    else
        producer_driver(buffer);
}

void producer_driver(buffer_t *b) {
    int item;

    while (1) {
        item = getchar();
        if (item == EOF) {
            producer(b, `\0');
            break;
        } else
            producer(b, (char)item);
    }
}

void consumer_driver(buffer_t *b) {
    char item;

    while (1) {
        if ((item = consumer(b)) == '\0')
            break;
        putchar(item);
    }
}</pre>
<hr>
<a name="6mba5vqa1"></a><h1 class="sol">Comparing Primitives</h1>
<p>The most basic synchronization primitive in threads is the mutual exclusion
lock. So, mutual exclusion lock is the most efficient mechanism in both memory
use and execution time. The basic use of a mutual exclusion lock is to serialize
access to a resource.</p>
<p>
<a name="sync-ix421"></a>The next most efficient primitive in threads is the
condition variable. The basic use of a condition variable is to block on a
change of state. The condition variable provides a thread wait facility. Remember
that a mutex lock must be acquired before blocking on a condition variable
and must be unlocked after returning from <kbd><b>pthread_cond_wait()</b></kbd>.
The mutex lock must also be held across the change of state that occurs before
the corresponding call to  <kbd><b>pthread_cond_signal()</b></kbd>.</p>
<p>
<a name="sync-ix422"></a><a name="sync-ix423"></a>The semaphore uses more memory than the condition variable. The
semaphore is easier to use in some circumstances because a semaphore variable
operates on state rather than on control. Unlike a lock, a semaphore does
not have an owner. Any thread can increment a semaphore that has blocked.</p>
<p>The read-write lock permits concurrent reads and exclusive writes to
a protected resource. The read-write lock is a single entity that can be locked
in  <b>read</b> or <b>write</b> mode. To modify
a resource, a thread must first acquire the exclusive write lock. An exclusive
write lock is not permitted until all read locks have been released.</p>
</div><div class="d8 d8v1" style="margin: 10px;"><div class="d8w1"><div class="d8w2"><div class="d8w3"><div class="d8w4"><ul><li class="d8left"><a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/attrib-74380/index.html"><em>Previous</em>: Chapter&nbsp;3 Thread Attributes</a></li><li class="d8right"><a href="http://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/gen-12013/index.html"><em>Next</em>: Chapter&nbsp;5 Programming With the Solaris
Software</a></li></ul></div></div></div></div></div><div class="a5 a5v0" id="a5">
<ul>
    <li class="copyright">© 2010, Oracle Corporation and/or its affiliates</li>
</ul>
</div>
</div></body></html>